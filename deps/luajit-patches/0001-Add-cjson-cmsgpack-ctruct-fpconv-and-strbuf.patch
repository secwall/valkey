diff --git a/src/Makefile b/src/Makefile
index 99642be7..4ffbd060 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -86,7 +86,7 @@ BUILDMODE= mixed
 ##############################################################################
 # Enable/disable these features as needed, but make sure you force a full
 # recompile with "make clean", followed by "make".
-XCFLAGS=
+XCFLAGS=-DENABLE_CJSON_GLOBAL
 #
 # Permanently disable the FFI extension to reduce the size of the LuaJIT
 # executable. But please consider that the FFI library is compiled-in,
@@ -500,6 +500,7 @@ LJVM_MODE= elfasm
 
 LJLIB_O= lib_base.o lib_math.o lib_bit.o lib_string.o lib_table.o \
 	 lib_io.o lib_os.o lib_package.o lib_debug.o lib_jit.o lib_ffi.o \
+	 fpconv.o lua_cjson.o lua_cmsgpack.o lua_struct.o strbuf.o \
 	 lib_buffer.o
 LJLIB_C= $(LJLIB_O:.o=.c)
 
diff --git a/src/fpconv.c b/src/fpconv.c
new file mode 100644
index 00000000..79908317
--- /dev/null
+++ b/src/fpconv.c
@@ -0,0 +1,205 @@
+/* fpconv - Floating point conversion routines
+ *
+ * Copyright (c) 2011-2012  Mark Pulford <mark@kyne.com.au>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/* JSON uses a '.' decimal separator. strtod() / sprintf() under C libraries
+ * with locale support will break when the decimal separator is a comma.
+ *
+ * fpconv_* will around these issues with a translation buffer if required.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <string.h>
+
+#include "fpconv.h"
+
+/* Lua CJSON assumes the locale is the same for all threads within a
+ * process and doesn't change after initialisation.
+ *
+ * This avoids the need for per thread storage or expensive checks
+ * for call. */
+static char locale_decimal_point = '.';
+
+/* In theory multibyte decimal_points are possible, but
+ * Lua CJSON only supports UTF-8 and known locales only have
+ * single byte decimal points ([.,]).
+ *
+ * localconv() may not be thread safe (=>crash), and nl_langinfo() is
+ * not supported on some platforms. Use sprintf() instead - if the
+ * locale does change, at least Lua CJSON won't crash. */
+static void fpconv_update_locale()
+{
+    char buf[8];
+
+    snprintf(buf, sizeof(buf), "%g", 0.5);
+
+    /* Failing this test might imply the platform has a buggy dtoa
+     * implementation or wide characters */
+    if (buf[0] != '0' || buf[2] != '5' || buf[3] != 0) {
+        fprintf(stderr, "Error: wide characters found or printf() bug.");
+        abort();
+    }
+
+    locale_decimal_point = buf[1];
+}
+
+/* Check for a valid number character: [-+0-9a-yA-Y.]
+ * Eg: -0.6e+5, infinity, 0xF0.F0pF0
+ *
+ * Used to find the probable end of a number. It doesn't matter if
+ * invalid characters are counted - strtod() will find the valid
+ * number if it exists.  The risk is that slightly more memory might
+ * be allocated before a parse error occurs. */
+static inline int valid_number_character(char ch)
+{
+    char lower_ch;
+
+    if ('0' <= ch && ch <= '9')
+        return 1;
+    if (ch == '-' || ch == '+' || ch == '.')
+        return 1;
+
+    /* Hex digits, exponent (e), base (p), "infinity",.. */
+    lower_ch = ch | 0x20;
+    if ('a' <= lower_ch && lower_ch <= 'y')
+        return 1;
+
+    return 0;
+}
+
+/* Calculate the size of the buffer required for a strtod locale
+ * conversion. */
+static int strtod_buffer_size(const char *s)
+{
+    const char *p = s;
+
+    while (valid_number_character(*p))
+        p++;
+
+    return p - s;
+}
+
+/* Similar to strtod(), but must be passed the current locale's decimal point
+ * character. Guaranteed to be called at the start of any valid number in a string */
+double fpconv_strtod(const char *nptr, char **endptr)
+{
+    char localbuf[FPCONV_G_FMT_BUFSIZE];
+    char *buf, *endbuf, *dp;
+    int buflen;
+    double value;
+
+    /* System strtod() is fine when decimal point is '.' */
+    if (locale_decimal_point == '.')
+        return strtod(nptr, endptr);
+
+    buflen = strtod_buffer_size(nptr);
+    if (!buflen) {
+        /* No valid characters found, standard strtod() return */
+        *endptr = (char *)nptr;
+        return 0;
+    }
+
+    /* Duplicate number into buffer */
+    if (buflen >= FPCONV_G_FMT_BUFSIZE) {
+        /* Handle unusually large numbers */
+        buf = malloc(buflen + 1);
+        if (!buf) {
+            fprintf(stderr, "Out of memory");
+            abort();
+        }
+    } else {
+        /* This is the common case.. */
+        buf = localbuf;
+    }
+    memcpy(buf, nptr, buflen);
+    buf[buflen] = 0;
+
+    /* Update decimal point character if found */
+    dp = strchr(buf, '.');
+    if (dp)
+        *dp = locale_decimal_point;
+
+    value = strtod(buf, &endbuf);
+    *endptr = (char *)&nptr[endbuf - buf];
+    if (buflen >= FPCONV_G_FMT_BUFSIZE)
+        free(buf);
+
+    return value;
+}
+
+/* "fmt" must point to a buffer of at least 6 characters */
+static void set_number_format(char *fmt, int precision)
+{
+    int d1, d2, i;
+
+    assert(1 <= precision && precision <= 14);
+
+    /* Create printf format (%.14g) from precision */
+    d1 = precision / 10;
+    d2 = precision % 10;
+    fmt[0] = '%';
+    fmt[1] = '.';
+    i = 2;
+    if (d1) {
+        fmt[i++] = '0' + d1;
+    }
+    fmt[i++] = '0' + d2;
+    fmt[i++] = 'g';
+    fmt[i] = 0;
+}
+
+/* Assumes there is always at least 32 characters available in the target buffer */
+int fpconv_g_fmt(char *str, double num, int precision)
+{
+    char buf[FPCONV_G_FMT_BUFSIZE];
+    char fmt[6];
+    int len;
+    char *b;
+
+    set_number_format(fmt, precision);
+
+    /* Pass through when decimal point character is dot. */
+    if (locale_decimal_point == '.')
+        return snprintf(str, FPCONV_G_FMT_BUFSIZE, fmt, num);
+
+    /* snprintf() to a buffer then translate for other decimal point characters */
+    len = snprintf(buf, FPCONV_G_FMT_BUFSIZE, fmt, num);
+
+    /* Copy into target location. Translate decimal point if required */
+    b = buf;
+    do {
+        *str++ = (*b == locale_decimal_point ? '.' : *b);
+    } while(*b++);
+
+    return len;
+}
+
+void fpconv_init()
+{
+    fpconv_update_locale();
+}
+
+/* vi:ai et sw=4 ts=4:
+ */
diff --git a/src/fpconv.h b/src/fpconv.h
new file mode 100644
index 00000000..7b0d0ee3
--- /dev/null
+++ b/src/fpconv.h
@@ -0,0 +1,22 @@
+/* Lua CJSON floating point conversion routines */
+
+/* Buffer required to store the largest string representation of a double.
+ *
+ * Longest double printed with %.14g is 21 characters long:
+ * -1.7976931348623e+308 */
+# define FPCONV_G_FMT_BUFSIZE   32
+
+#ifdef USE_INTERNAL_FPCONV
+static inline void fpconv_init()
+{
+    /* Do nothing - not required */
+}
+#else
+extern void fpconv_init();
+#endif
+
+extern int fpconv_g_fmt(char*, double, int);
+extern double fpconv_strtod(const char*, char**);
+
+/* vi:ai et sw=4 ts=4:
+ */
diff --git a/src/lua_cjson.c b/src/lua_cjson.c
new file mode 100644
index 00000000..fc78da74
--- /dev/null
+++ b/src/lua_cjson.c
@@ -0,0 +1,1409 @@
+/* Lua CJSON - JSON support for Lua
+ *
+ * Copyright (c) 2010-2012  Mark Pulford <mark@kyne.com.au>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/* Caveats:
+ * - JSON "null" values are represented as lightuserdata since Lua
+ *   tables cannot contain "nil". Compare with cjson.null.
+ * - Invalid UTF-8 characters are not detected and will be passed
+ *   untouched. If required, UTF-8 error checking should be done
+ *   outside this library.
+ * - Javascript comments are not part of the JSON spec, and are not
+ *   currently supported.
+ *
+ * Note: Decoding is slower than encoding. Lua spends significant
+ *       time (30%) managing tables when parsing JSON since it is
+ *       difficult to know object/array sizes ahead of time.
+ */
+
+#include <assert.h>
+#include <string.h>
+#include <math.h>
+#include <stdint.h>
+#include <limits.h>
+#include "lua.h"
+#include "lauxlib.h"
+
+#include "strbuf.h"
+#include "fpconv.h"
+
+#include "../../../src/solarisfixes.h"
+
+#ifndef CJSON_MODNAME
+#define CJSON_MODNAME   "cjson"
+#endif
+
+#ifndef CJSON_VERSION
+#define CJSON_VERSION   "2.1.0"
+#endif
+
+/* Workaround for Solaris platforms missing isinf() */
+#if !defined(isinf) && (defined(USE_INTERNAL_ISINF) || defined(MISSING_ISINF))
+#define isinf(x) (!isnan(x) && isnan((x) - (x)))
+#endif
+
+#define DEFAULT_SPARSE_CONVERT 0
+#define DEFAULT_SPARSE_RATIO 2
+#define DEFAULT_SPARSE_SAFE 10
+#define DEFAULT_ENCODE_MAX_DEPTH 1000
+#define DEFAULT_DECODE_MAX_DEPTH 1000
+#define DEFAULT_ENCODE_INVALID_NUMBERS 0
+#define DEFAULT_DECODE_INVALID_NUMBERS 1
+#define DEFAULT_ENCODE_KEEP_BUFFER 0
+#define DEFAULT_ENCODE_NUMBER_PRECISION 14
+
+#ifdef DISABLE_INVALID_NUMBERS
+#undef DEFAULT_DECODE_INVALID_NUMBERS
+#define DEFAULT_DECODE_INVALID_NUMBERS 0
+#endif
+
+typedef enum {
+    T_OBJ_BEGIN,
+    T_OBJ_END,
+    T_ARR_BEGIN,
+    T_ARR_END,
+    T_STRING,
+    T_NUMBER,
+    T_BOOLEAN,
+    T_NULL,
+    T_COLON,
+    T_COMMA,
+    T_END,
+    T_WHITESPACE,
+    T_ERROR,
+    T_UNKNOWN
+} json_token_type_t;
+
+static const char *json_token_type_name[] = {
+    "T_OBJ_BEGIN",
+    "T_OBJ_END",
+    "T_ARR_BEGIN",
+    "T_ARR_END",
+    "T_STRING",
+    "T_NUMBER",
+    "T_BOOLEAN",
+    "T_NULL",
+    "T_COLON",
+    "T_COMMA",
+    "T_END",
+    "T_WHITESPACE",
+    "T_ERROR",
+    "T_UNKNOWN",
+    NULL
+};
+
+typedef struct {
+    json_token_type_t ch2token[256];
+    char escape2char[256];  /* Decoding */
+
+    /* encode_buf is only allocated and used when
+     * encode_keep_buffer is set */
+    strbuf_t encode_buf;
+
+    int encode_sparse_convert;
+    int encode_sparse_ratio;
+    int encode_sparse_safe;
+    int encode_max_depth;
+    int encode_invalid_numbers;     /* 2 => Encode as "null" */
+    int encode_number_precision;
+    int encode_keep_buffer;
+
+    int decode_invalid_numbers;
+    int decode_max_depth;
+} json_config_t;
+
+typedef struct {
+    const char *data;
+    const char *ptr;
+    strbuf_t *tmp;    /* Temporary storage for strings */
+    json_config_t *cfg;
+    int current_depth;
+} json_parse_t;
+
+typedef struct {
+    json_token_type_t type;
+    size_t index;
+    union {
+        const char *string;
+        double number;
+        int boolean;
+    } value;
+    size_t string_len;
+} json_token_t;
+
+static const char *char2escape[256] = {
+    "\\u0000", "\\u0001", "\\u0002", "\\u0003",
+    "\\u0004", "\\u0005", "\\u0006", "\\u0007",
+    "\\b", "\\t", "\\n", "\\u000b",
+    "\\f", "\\r", "\\u000e", "\\u000f",
+    "\\u0010", "\\u0011", "\\u0012", "\\u0013",
+    "\\u0014", "\\u0015", "\\u0016", "\\u0017",
+    "\\u0018", "\\u0019", "\\u001a", "\\u001b",
+    "\\u001c", "\\u001d", "\\u001e", "\\u001f",
+    NULL, NULL, "\\\"", NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, "\\/",
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, "\\\\", NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, "\\u007f",
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+};
+
+/* ===== CONFIGURATION ===== */
+
+static json_config_t *json_fetch_config(lua_State *l)
+{
+    json_config_t *cfg;
+
+    cfg = lua_touserdata(l, lua_upvalueindex(1));
+    if (!cfg)
+        luaL_error(l, "BUG: Unable to fetch CJSON configuration");
+
+    return cfg;
+}
+
+/* Ensure the correct number of arguments have been provided.
+ * Pad with nil to allow other functions to simply check arg[i]
+ * to find whether an argument was provided */
+static json_config_t *json_arg_init(lua_State *l, int args)
+{
+    luaL_argcheck(l, lua_gettop(l) <= args, args + 1,
+                  "found too many arguments");
+
+    while (lua_gettop(l) < args)
+        lua_pushnil(l);
+
+    return json_fetch_config(l);
+}
+
+/* Process integer options for configuration functions */
+static int json_integer_option(lua_State *l, int optindex, int *setting,
+                               int min, int max)
+{
+    char errmsg[64];
+    int value;
+
+    if (!lua_isnil(l, optindex)) {
+        value = luaL_checkinteger(l, optindex);
+        snprintf(errmsg, sizeof(errmsg), "expected integer between %d and %d", min, max);
+        luaL_argcheck(l, min <= value && value <= max, 1, errmsg);
+        *setting = value;
+    }
+
+    lua_pushinteger(l, *setting);
+
+    return 1;
+}
+
+/* Process enumerated arguments for a configuration function */
+static int json_enum_option(lua_State *l, int optindex, int *setting,
+                            const char **options, int bool_true)
+{
+    static const char *bool_options[] = { "off", "on", NULL };
+
+    if (!options) {
+        options = bool_options;
+        bool_true = 1;
+    }
+
+    if (!lua_isnil(l, optindex)) {
+        if (bool_true && lua_isboolean(l, optindex))
+            *setting = lua_toboolean(l, optindex) * bool_true;
+        else
+            *setting = luaL_checkoption(l, optindex, NULL, options);
+    }
+
+    if (bool_true && (*setting == 0 || *setting == bool_true))
+        lua_pushboolean(l, *setting);
+    else
+        lua_pushstring(l, options[*setting]);
+
+    return 1;
+}
+
+/* Configures handling of extremely sparse arrays:
+ * convert: Convert extremely sparse arrays into objects? Otherwise error.
+ * ratio: 0: always allow sparse; 1: never allow sparse; >1: use ratio
+ * safe: Always use an array when the max index <= safe */
+static int json_cfg_encode_sparse_array(lua_State *l)
+{
+    json_config_t *cfg = json_arg_init(l, 3);
+
+    json_enum_option(l, 1, &cfg->encode_sparse_convert, NULL, 1);
+    json_integer_option(l, 2, &cfg->encode_sparse_ratio, 0, INT_MAX);
+    json_integer_option(l, 3, &cfg->encode_sparse_safe, 0, INT_MAX);
+
+    return 3;
+}
+
+/* Configures the maximum number of nested arrays/objects allowed when
+ * encoding */
+static int json_cfg_encode_max_depth(lua_State *l)
+{
+    json_config_t *cfg = json_arg_init(l, 1);
+
+    return json_integer_option(l, 1, &cfg->encode_max_depth, 1, INT_MAX);
+}
+
+/* Configures the maximum number of nested arrays/objects allowed when
+ * encoding */
+static int json_cfg_decode_max_depth(lua_State *l)
+{
+    json_config_t *cfg = json_arg_init(l, 1);
+
+    return json_integer_option(l, 1, &cfg->decode_max_depth, 1, INT_MAX);
+}
+
+/* Configures number precision when converting doubles to text */
+static int json_cfg_encode_number_precision(lua_State *l)
+{
+    json_config_t *cfg = json_arg_init(l, 1);
+
+    return json_integer_option(l, 1, &cfg->encode_number_precision, 1, 14);
+}
+
+/* Configures JSON encoding buffer persistence */
+static int json_cfg_encode_keep_buffer(lua_State *l)
+{
+    json_config_t *cfg = json_arg_init(l, 1);
+    int old_value;
+
+    old_value = cfg->encode_keep_buffer;
+
+    json_enum_option(l, 1, &cfg->encode_keep_buffer, NULL, 1);
+
+    /* Init / free the buffer if the setting has changed */
+    if (old_value ^ cfg->encode_keep_buffer) {
+        if (cfg->encode_keep_buffer)
+            strbuf_init(&cfg->encode_buf, 0);
+        else
+            strbuf_free(&cfg->encode_buf);
+    }
+
+    return 1;
+}
+
+#if defined(DISABLE_INVALID_NUMBERS) && !defined(USE_INTERNAL_FPCONV)
+void json_verify_invalid_number_setting(lua_State *l, int *setting)
+{
+    if (*setting == 1) {
+        *setting = 0;
+        luaL_error(l, "Infinity, NaN, and/or hexadecimal numbers are not supported.");
+    }
+}
+#else
+#define json_verify_invalid_number_setting(l, s)    do { } while(0)
+#endif
+
+static int json_cfg_encode_invalid_numbers(lua_State *l)
+{
+    static const char *options[] = { "off", "on", "null", NULL };
+    json_config_t *cfg = json_arg_init(l, 1);
+
+    json_enum_option(l, 1, &cfg->encode_invalid_numbers, options, 1);
+
+    json_verify_invalid_number_setting(l, &cfg->encode_invalid_numbers);
+
+    return 1;
+}
+
+static int json_cfg_decode_invalid_numbers(lua_State *l)
+{
+    json_config_t *cfg = json_arg_init(l, 1);
+
+    json_enum_option(l, 1, &cfg->decode_invalid_numbers, NULL, 1);
+
+    json_verify_invalid_number_setting(l, &cfg->encode_invalid_numbers);
+
+    return 1;
+}
+
+static int json_destroy_config(lua_State *l)
+{
+    json_config_t *cfg;
+
+    cfg = lua_touserdata(l, 1);
+    if (cfg)
+        strbuf_free(&cfg->encode_buf);
+    cfg = NULL;
+
+    return 0;
+}
+
+static void json_create_config(lua_State *l)
+{
+    json_config_t *cfg;
+    int i;
+
+    cfg = lua_newuserdata(l, sizeof(*cfg));
+
+    /* Create GC method to clean up strbuf */
+    lua_newtable(l);
+    lua_pushcfunction(l, json_destroy_config);
+    lua_setfield(l, -2, "__gc");
+    lua_setmetatable(l, -2);
+
+    cfg->encode_sparse_convert = DEFAULT_SPARSE_CONVERT;
+    cfg->encode_sparse_ratio = DEFAULT_SPARSE_RATIO;
+    cfg->encode_sparse_safe = DEFAULT_SPARSE_SAFE;
+    cfg->encode_max_depth = DEFAULT_ENCODE_MAX_DEPTH;
+    cfg->decode_max_depth = DEFAULT_DECODE_MAX_DEPTH;
+    cfg->encode_invalid_numbers = DEFAULT_ENCODE_INVALID_NUMBERS;
+    cfg->decode_invalid_numbers = DEFAULT_DECODE_INVALID_NUMBERS;
+    cfg->encode_keep_buffer = DEFAULT_ENCODE_KEEP_BUFFER;
+    cfg->encode_number_precision = DEFAULT_ENCODE_NUMBER_PRECISION;
+
+#if DEFAULT_ENCODE_KEEP_BUFFER > 0
+    strbuf_init(&cfg->encode_buf, 0);
+#endif
+
+    /* Decoding init */
+
+    /* Tag all characters as an error */
+    for (i = 0; i < 256; i++)
+        cfg->ch2token[i] = T_ERROR;
+
+    /* Set tokens that require no further processing */
+    cfg->ch2token['{'] = T_OBJ_BEGIN;
+    cfg->ch2token['}'] = T_OBJ_END;
+    cfg->ch2token['['] = T_ARR_BEGIN;
+    cfg->ch2token[']'] = T_ARR_END;
+    cfg->ch2token[','] = T_COMMA;
+    cfg->ch2token[':'] = T_COLON;
+    cfg->ch2token['\0'] = T_END;
+    cfg->ch2token[' '] = T_WHITESPACE;
+    cfg->ch2token['\t'] = T_WHITESPACE;
+    cfg->ch2token['\n'] = T_WHITESPACE;
+    cfg->ch2token['\r'] = T_WHITESPACE;
+
+    /* Update characters that require further processing */
+    cfg->ch2token['f'] = T_UNKNOWN;     /* false? */
+    cfg->ch2token['i'] = T_UNKNOWN;     /* inf, ininity? */
+    cfg->ch2token['I'] = T_UNKNOWN;
+    cfg->ch2token['n'] = T_UNKNOWN;     /* null, nan? */
+    cfg->ch2token['N'] = T_UNKNOWN;
+    cfg->ch2token['t'] = T_UNKNOWN;     /* true? */
+    cfg->ch2token['"'] = T_UNKNOWN;     /* string? */
+    cfg->ch2token['+'] = T_UNKNOWN;     /* number? */
+    cfg->ch2token['-'] = T_UNKNOWN;
+    for (i = 0; i < 10; i++)
+        cfg->ch2token['0' + i] = T_UNKNOWN;
+
+    /* Lookup table for parsing escape characters */
+    for (i = 0; i < 256; i++)
+        cfg->escape2char[i] = 0;          /* String error */
+    cfg->escape2char['"'] = '"';
+    cfg->escape2char['\\'] = '\\';
+    cfg->escape2char['/'] = '/';
+    cfg->escape2char['b'] = '\b';
+    cfg->escape2char['t'] = '\t';
+    cfg->escape2char['n'] = '\n';
+    cfg->escape2char['f'] = '\f';
+    cfg->escape2char['r'] = '\r';
+    cfg->escape2char['u'] = 'u';          /* Unicode parsing required */
+}
+
+/* ===== ENCODING ===== */
+
+static void json_encode_exception(lua_State *l, json_config_t *cfg, strbuf_t *json, int lindex,
+                                  const char *reason)
+{
+    if (!cfg->encode_keep_buffer)
+        strbuf_free(json);
+    luaL_error(l, "Cannot serialise %s: %s",
+                  lua_typename(l, lua_type(l, lindex)), reason);
+}
+
+/* json_append_string args:
+ * - lua_State
+ * - JSON strbuf
+ * - String (Lua stack index)
+ *
+ * Returns nothing. Doesn't remove string from Lua stack */
+static void json_append_string(lua_State *l, strbuf_t *json, int lindex)
+{
+    const char *escstr;
+    const char *str;
+    size_t i, len;
+
+    str = lua_tolstring(l, lindex, &len);
+
+    /* Worst case is len * 6 (all unicode escapes).
+     * This buffer is reused constantly for small strings
+     * If there are any excess pages, they won't be hit anyway.
+     * This gains ~5% speedup. */
+    if (len > SIZE_MAX / 6 - 3)
+        abort(); /* Overflow check */
+    strbuf_ensure_empty_length(json, len * 6 + 2);
+
+    strbuf_append_char_unsafe(json, '\"');
+    for (i = 0; i < len; i++) {
+        escstr = char2escape[(unsigned char)str[i]];
+        if (escstr)
+            strbuf_append_string(json, escstr);
+        else
+            strbuf_append_char_unsafe(json, str[i]);
+    }
+    strbuf_append_char_unsafe(json, '\"');
+}
+
+/* Find the size of the array on the top of the Lua stack
+ * -1   object (not a pure array)
+ * >=0  elements in array
+ */
+static int lua_array_length(lua_State *l, json_config_t *cfg, strbuf_t *json)
+{
+    double k;
+    int max;
+    int items;
+
+    max = 0;
+    items = 0;
+
+    lua_pushnil(l);
+    /* table, startkey */
+    while (lua_next(l, -2) != 0) {
+        /* table, key, value */
+        if (lua_type(l, -2) == LUA_TNUMBER &&
+            (k = lua_tonumber(l, -2))) {
+            /* Integer >= 1 ? */
+            if (floor(k) == k && k >= 1) {
+                if (k > max)
+                    max = k;
+                items++;
+                lua_pop(l, 1);
+                continue;
+            }
+        }
+
+        /* Must not be an array (non integer key) */
+        lua_pop(l, 2);
+        return -1;
+    }
+
+    /* Encode excessively sparse arrays as objects (if enabled) */
+    if (cfg->encode_sparse_ratio > 0 &&
+        max > items * cfg->encode_sparse_ratio &&
+        max > cfg->encode_sparse_safe) {
+        if (!cfg->encode_sparse_convert)
+            json_encode_exception(l, cfg, json, -1, "excessively sparse array");
+
+        return -1;
+    }
+
+    return max;
+}
+
+static void json_check_encode_depth(lua_State *l, json_config_t *cfg,
+                                    int current_depth, strbuf_t *json)
+{
+    /* Ensure there are enough slots free to traverse a table (key,
+     * value) and push a string for a potential error message.
+     *
+     * Unlike "decode", the key and value are still on the stack when
+     * lua_checkstack() is called.  Hence an extra slot for luaL_error()
+     * below is required just in case the next check to lua_checkstack()
+     * fails.
+     *
+     * While this won't cause a crash due to the EXTRA_STACK reserve
+     * slots, it would still be an improper use of the API. */
+    if (current_depth <= cfg->encode_max_depth && lua_checkstack(l, 3))
+        return;
+
+    if (!cfg->encode_keep_buffer)
+        strbuf_free(json);
+
+    luaL_error(l, "Cannot serialise, excessive nesting (%d)",
+               current_depth);
+}
+
+static void json_append_data(lua_State *l, json_config_t *cfg,
+                             int current_depth, strbuf_t *json);
+
+/* json_append_array args:
+ * - lua_State
+ * - JSON strbuf
+ * - Size of passwd Lua array (top of stack) */
+static void json_append_array(lua_State *l, json_config_t *cfg, int current_depth,
+                              strbuf_t *json, int array_length)
+{
+    int comma, i;
+
+    strbuf_append_char(json, '[');
+
+    comma = 0;
+    for (i = 1; i <= array_length; i++) {
+        if (comma)
+            strbuf_append_char(json, ',');
+        else
+            comma = 1;
+
+        lua_rawgeti(l, -1, i);
+        json_append_data(l, cfg, current_depth, json);
+        lua_pop(l, 1);
+    }
+
+    strbuf_append_char(json, ']');
+}
+
+static void json_append_number(lua_State *l, json_config_t *cfg,
+                               strbuf_t *json, int lindex)
+{
+    double num = lua_tonumber(l, lindex);
+    int len;
+
+    if (cfg->encode_invalid_numbers == 0) {
+        /* Prevent encoding invalid numbers */
+        if (isinf(num) || isnan(num))
+            json_encode_exception(l, cfg, json, lindex, "must not be NaN or Inf");
+    } else if (cfg->encode_invalid_numbers == 1) {
+        /* Encode invalid numbers, but handle "nan" separately
+         * since some platforms may encode as "-nan". */
+        if (isnan(num)) {
+            strbuf_append_mem(json, "nan", 3);
+            return;
+        }
+    } else {
+        /* Encode invalid numbers as "null" */
+        if (isinf(num) || isnan(num)) {
+            strbuf_append_mem(json, "null", 4);
+            return;
+        }
+    }
+
+    strbuf_ensure_empty_length(json, FPCONV_G_FMT_BUFSIZE);
+    len = fpconv_g_fmt(strbuf_empty_ptr(json), num, cfg->encode_number_precision);
+    strbuf_extend_length(json, len);
+}
+
+static void json_append_object(lua_State *l, json_config_t *cfg,
+                               int current_depth, strbuf_t *json)
+{
+    int comma, keytype;
+
+    /* Object */
+    strbuf_append_char(json, '{');
+
+    lua_pushnil(l);
+    /* table, startkey */
+    comma = 0;
+    while (lua_next(l, -2) != 0) {
+        if (comma)
+            strbuf_append_char(json, ',');
+        else
+            comma = 1;
+
+        /* table, key, value */
+        keytype = lua_type(l, -2);
+        if (keytype == LUA_TNUMBER) {
+            strbuf_append_char(json, '"');
+            json_append_number(l, cfg, json, -2);
+            strbuf_append_mem(json, "\":", 2);
+        } else if (keytype == LUA_TSTRING) {
+            json_append_string(l, json, -2);
+            strbuf_append_char(json, ':');
+        } else {
+            json_encode_exception(l, cfg, json, -2,
+                                  "table key must be a number or string");
+            /* never returns */
+        }
+
+        /* table, key, value */
+        json_append_data(l, cfg, current_depth, json);
+        lua_pop(l, 1);
+        /* table, key */
+    }
+
+    strbuf_append_char(json, '}');
+}
+
+/* Serialise Lua data into JSON string. */
+static void json_append_data(lua_State *l, json_config_t *cfg,
+                             int current_depth, strbuf_t *json)
+{
+    int len;
+
+    switch (lua_type(l, -1)) {
+    case LUA_TSTRING:
+        json_append_string(l, json, -1);
+        break;
+    case LUA_TNUMBER:
+        json_append_number(l, cfg, json, -1);
+        break;
+    case LUA_TBOOLEAN:
+        if (lua_toboolean(l, -1))
+            strbuf_append_mem(json, "true", 4);
+        else
+            strbuf_append_mem(json, "false", 5);
+        break;
+    case LUA_TTABLE:
+        current_depth++;
+        json_check_encode_depth(l, cfg, current_depth, json);
+        len = lua_array_length(l, cfg, json);
+        if (len > 0)
+            json_append_array(l, cfg, current_depth, json, len);
+        else
+            json_append_object(l, cfg, current_depth, json);
+        break;
+    case LUA_TNIL:
+        strbuf_append_mem(json, "null", 4);
+        break;
+    case LUA_TLIGHTUSERDATA:
+        if (lua_touserdata(l, -1) == NULL) {
+            strbuf_append_mem(json, "null", 4);
+            break;
+        }
+    default:
+        /* Remaining types (LUA_TFUNCTION, LUA_TUSERDATA, LUA_TTHREAD,
+         * and LUA_TLIGHTUSERDATA) cannot be serialised */
+        json_encode_exception(l, cfg, json, -1, "type not supported");
+        /* never returns */
+    }
+}
+
+static int json_encode(lua_State *l)
+{
+    json_config_t *cfg = json_fetch_config(l);
+    strbuf_t local_encode_buf;
+    strbuf_t *encode_buf;
+    char *json;
+    size_t len;
+
+    luaL_argcheck(l, lua_gettop(l) == 1, 1, "expected 1 argument");
+
+    if (!cfg->encode_keep_buffer) {
+        /* Use private buffer */
+        encode_buf = &local_encode_buf;
+        strbuf_init(encode_buf, 0);
+    } else {
+        /* Reuse existing buffer */
+        encode_buf = &cfg->encode_buf;
+        strbuf_reset(encode_buf);
+    }
+
+    json_append_data(l, cfg, 0, encode_buf);
+    json = strbuf_string(encode_buf, &len);
+
+    lua_pushlstring(l, json, len);
+
+    if (!cfg->encode_keep_buffer)
+        strbuf_free(encode_buf);
+
+    return 1;
+}
+
+/* ===== DECODING ===== */
+
+static void json_process_value(lua_State *l, json_parse_t *json,
+                               json_token_t *token);
+
+static int hexdigit2int(char hex)
+{
+    if ('0' <= hex  && hex <= '9')
+        return hex - '0';
+
+    /* Force lowercase */
+    hex |= 0x20;
+    if ('a' <= hex && hex <= 'f')
+        return 10 + hex - 'a';
+
+    return -1;
+}
+
+static int decode_hex4(const char *hex)
+{
+    int digit[4];
+    int i;
+
+    /* Convert ASCII hex digit to numeric digit
+     * Note: this returns an error for invalid hex digits, including
+     *       NULL */
+    for (i = 0; i < 4; i++) {
+        digit[i] = hexdigit2int(hex[i]);
+        if (digit[i] < 0) {
+            return -1;
+        }
+    }
+
+    return (digit[0] << 12) +
+           (digit[1] << 8) +
+           (digit[2] << 4) +
+            digit[3];
+}
+
+/* Converts a Unicode codepoint to UTF-8.
+ * Returns UTF-8 string length, and up to 4 bytes in *utf8 */
+static int codepoint_to_utf8(char *utf8, int codepoint)
+{
+    /* 0xxxxxxx */
+    if (codepoint <= 0x7F) {
+        utf8[0] = codepoint;
+        return 1;
+    }
+
+    /* 110xxxxx 10xxxxxx */
+    if (codepoint <= 0x7FF) {
+        utf8[0] = (codepoint >> 6) | 0xC0;
+        utf8[1] = (codepoint & 0x3F) | 0x80;
+        return 2;
+    }
+
+    /* 1110xxxx 10xxxxxx 10xxxxxx */
+    if (codepoint <= 0xFFFF) {
+        utf8[0] = (codepoint >> 12) | 0xE0;
+        utf8[1] = ((codepoint >> 6) & 0x3F) | 0x80;
+        utf8[2] = (codepoint & 0x3F) | 0x80;
+        return 3;
+    }
+
+    /* 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
+    if (codepoint <= 0x1FFFFF) {
+        utf8[0] = (codepoint >> 18) | 0xF0;
+        utf8[1] = ((codepoint >> 12) & 0x3F) | 0x80;
+        utf8[2] = ((codepoint >> 6) & 0x3F) | 0x80;
+        utf8[3] = (codepoint & 0x3F) | 0x80;
+        return 4;
+    }
+
+    return 0;
+}
+
+
+/* Called when index pointing to beginning of UTF-16 code escape: \uXXXX
+ * \u is guaranteed to exist, but the remaining hex characters may be
+ * missing.
+ * Translate to UTF-8 and append to temporary token string.
+ * Must advance index to the next character to be processed.
+ * Returns: 0   success
+ *          -1  error
+ */
+static int json_append_unicode_escape(json_parse_t *json)
+{
+    char utf8[4];       /* Surrogate pairs require 4 UTF-8 bytes */
+    int codepoint;
+    int surrogate_low;
+    int len;
+    int escape_len = 6;
+
+    /* Fetch UTF-16 code unit */
+    codepoint = decode_hex4(json->ptr + 2);
+    if (codepoint < 0)
+        return -1;
+
+    /* UTF-16 surrogate pairs take the following 2 byte form:
+     *      11011 x yyyyyyyyyy
+     * When x = 0: y is the high 10 bits of the codepoint
+     *      x = 1: y is the low 10 bits of the codepoint
+     *
+     * Check for a surrogate pair (high or low) */
+    if ((codepoint & 0xF800) == 0xD800) {
+        /* Error if the 1st surrogate is not high */
+        if (codepoint & 0x400)
+            return -1;
+
+        /* Ensure the next code is a unicode escape */
+        if (*(json->ptr + escape_len) != '\\' ||
+            *(json->ptr + escape_len + 1) != 'u') {
+            return -1;
+        }
+
+        /* Fetch the next codepoint */
+        surrogate_low = decode_hex4(json->ptr + 2 + escape_len);
+        if (surrogate_low < 0)
+            return -1;
+
+        /* Error if the 2nd code is not a low surrogate */
+        if ((surrogate_low & 0xFC00) != 0xDC00)
+            return -1;
+
+        /* Calculate Unicode codepoint */
+        codepoint = (codepoint & 0x3FF) << 10;
+        surrogate_low &= 0x3FF;
+        codepoint = (codepoint | surrogate_low) + 0x10000;
+        escape_len = 12;
+    }
+
+    /* Convert codepoint to UTF-8 */
+    len = codepoint_to_utf8(utf8, codepoint);
+    if (!len)
+        return -1;
+
+    /* Append bytes and advance parse index */
+    strbuf_append_mem_unsafe(json->tmp, utf8, len);
+    json->ptr += escape_len;
+
+    return 0;
+}
+
+static void json_set_token_error(json_token_t *token, json_parse_t *json,
+                                 const char *errtype)
+{
+    token->type = T_ERROR;
+    token->index = json->ptr - json->data;
+    token->value.string = errtype;
+}
+
+static void json_next_string_token(json_parse_t *json, json_token_t *token)
+{
+    char *escape2char = json->cfg->escape2char;
+    char ch;
+
+    /* Caller must ensure a string is next */
+    assert(*json->ptr == '"');
+
+    /* Skip " */
+    json->ptr++;
+
+    /* json->tmp is the temporary strbuf used to accumulate the
+     * decoded string value.
+     * json->tmp is sized to handle JSON containing only a string value.
+     */
+    strbuf_reset(json->tmp);
+
+    while ((ch = *json->ptr) != '"') {
+        if (!ch) {
+            /* Premature end of the string */
+            json_set_token_error(token, json, "unexpected end of string");
+            return;
+        }
+
+        /* Handle escapes */
+        if (ch == '\\') {
+            /* Fetch escape character */
+            ch = *(json->ptr + 1);
+
+            /* Translate escape code and append to tmp string */
+            ch = escape2char[(unsigned char)ch];
+            if (ch == 'u') {
+                if (json_append_unicode_escape(json) == 0)
+                    continue;
+
+                json_set_token_error(token, json,
+                                     "invalid unicode escape code");
+                return;
+            }
+            if (!ch) {
+                json_set_token_error(token, json, "invalid escape code");
+                return;
+            }
+
+            /* Skip '\' */
+            json->ptr++;
+        }
+        /* Append normal character or translated single character
+         * Unicode escapes are handled above */
+        strbuf_append_char_unsafe(json->tmp, ch);
+        json->ptr++;
+    }
+    json->ptr++;    /* Eat final quote (") */
+
+    strbuf_ensure_null(json->tmp);
+
+    token->type = T_STRING;
+    token->value.string = strbuf_string(json->tmp, &token->string_len);
+}
+
+/* JSON numbers should take the following form:
+ *      -?(0|[1-9]|[1-9][0-9]+)(.[0-9]+)?([eE][-+]?[0-9]+)?
+ *
+ * json_next_number_token() uses strtod() which allows other forms:
+ * - numbers starting with '+'
+ * - NaN, -NaN, infinity, -infinity
+ * - hexadecimal numbers
+ * - numbers with leading zeros
+ *
+ * json_is_invalid_number() detects "numbers" which may pass strtod()'s
+ * error checking, but should not be allowed with strict JSON.
+ *
+ * json_is_invalid_number() may pass numbers which cause strtod()
+ * to generate an error.
+ */
+static int json_is_invalid_number(json_parse_t *json)
+{
+    const char *p = json->ptr;
+
+    /* Reject numbers starting with + */
+    if (*p == '+')
+        return 1;
+
+    /* Skip minus sign if it exists */
+    if (*p == '-')
+        p++;
+
+    /* Reject numbers starting with 0x, or leading zeros */
+    if (*p == '0') {
+        int ch2 = *(p + 1);
+
+        if ((ch2 | 0x20) == 'x' ||          /* Hex */
+            ('0' <= ch2 && ch2 <= '9'))     /* Leading zero */
+            return 1;
+
+        return 0;
+    } else if (*p <= '9') {
+        return 0;                           /* Ordinary number */
+    }
+
+    /* Reject inf/nan */
+    if (!strncasecmp(p, "inf", 3))
+        return 1;
+    if (!strncasecmp(p, "nan", 3))
+        return 1;
+
+    /* Pass all other numbers which may still be invalid, but
+     * strtod() will catch them. */
+    return 0;
+}
+
+static void json_next_number_token(json_parse_t *json, json_token_t *token)
+{
+    char *endptr;
+
+    token->type = T_NUMBER;
+    token->value.number = fpconv_strtod(json->ptr, &endptr);
+    if (json->ptr == endptr)
+        json_set_token_error(token, json, "invalid number");
+    else
+        json->ptr = endptr;     /* Skip the processed number */
+
+    return;
+}
+
+/* Fills in the token struct.
+ * T_STRING will return a pointer to the json_parse_t temporary string
+ * T_ERROR will leave the json->ptr pointer at the error.
+ */
+static void json_next_token(json_parse_t *json, json_token_t *token)
+{
+    const json_token_type_t *ch2token = json->cfg->ch2token;
+    int ch;
+
+    /* Eat whitespace. */
+    while (1) {
+        ch = (unsigned char)*(json->ptr);
+        token->type = ch2token[ch];
+        if (token->type != T_WHITESPACE)
+            break;
+        json->ptr++;
+    }
+
+    /* Store location of new token. Required when throwing errors
+     * for unexpected tokens (syntax errors). */
+    token->index = json->ptr - json->data;
+
+    /* Don't advance the pointer for an error or the end */
+    if (token->type == T_ERROR) {
+        json_set_token_error(token, json, "invalid token");
+        return;
+    }
+
+    if (token->type == T_END) {
+        return;
+    }
+
+    /* Found a known single character token, advance index and return */
+    if (token->type != T_UNKNOWN) {
+        json->ptr++;
+        return;
+    }
+
+    /* Process characters which triggered T_UNKNOWN
+     *
+     * Must use strncmp() to match the front of the JSON string.
+     * JSON identifier must be lowercase.
+     * When strict_numbers if disabled, either case is allowed for
+     * Infinity/NaN (since we are no longer following the spec..) */
+    if (ch == '"') {
+        json_next_string_token(json, token);
+        return;
+    } else if (ch == '-' || ('0' <= ch && ch <= '9')) {
+        if (!json->cfg->decode_invalid_numbers && json_is_invalid_number(json)) {
+            json_set_token_error(token, json, "invalid number");
+            return;
+        }
+        json_next_number_token(json, token);
+        return;
+    } else if (!strncmp(json->ptr, "true", 4)) {
+        token->type = T_BOOLEAN;
+        token->value.boolean = 1;
+        json->ptr += 4;
+        return;
+    } else if (!strncmp(json->ptr, "false", 5)) {
+        token->type = T_BOOLEAN;
+        token->value.boolean = 0;
+        json->ptr += 5;
+        return;
+    } else if (!strncmp(json->ptr, "null", 4)) {
+        token->type = T_NULL;
+        json->ptr += 4;
+        return;
+    } else if (json->cfg->decode_invalid_numbers &&
+               json_is_invalid_number(json)) {
+        /* When decode_invalid_numbers is enabled, only attempt to process
+         * numbers we know are invalid JSON (Inf, NaN, hex)
+         * This is required to generate an appropriate token error,
+         * otherwise all bad tokens will register as "invalid number"
+         */
+        json_next_number_token(json, token);
+        return;
+    }
+
+    /* Token starts with t/f/n but isn't recognised above. */
+    json_set_token_error(token, json, "invalid token");
+}
+
+/* This function does not return.
+ * DO NOT CALL WITH DYNAMIC MEMORY ALLOCATED.
+ * The only supported exception is the temporary parser string
+ * json->tmp struct.
+ * json and token should exist on the stack somewhere.
+ * luaL_error() will long_jmp and release the stack */
+static void json_throw_parse_error(lua_State *l, json_parse_t *json,
+                                   const char *exp, json_token_t *token)
+{
+    const char *found;
+
+    strbuf_free(json->tmp);
+
+    if (token->type == T_ERROR)
+        found = token->value.string;
+    else
+        found = json_token_type_name[token->type];
+
+    /* Note: token->index is 0 based, display starting from 1 */
+    luaL_error(l, "Expected %s but found %s at character %d",
+               exp, found, token->index + 1);
+}
+
+static inline void json_decode_ascend(json_parse_t *json)
+{
+    json->current_depth--;
+}
+
+static void json_decode_descend(lua_State *l, json_parse_t *json, int slots)
+{
+    json->current_depth++;
+
+    if (json->current_depth <= json->cfg->decode_max_depth &&
+        lua_checkstack(l, slots)) {
+        return;
+    }
+
+    strbuf_free(json->tmp);
+    luaL_error(l, "Found too many nested data structures (%d) at character %d",
+        json->current_depth, json->ptr - json->data);
+}
+
+static void json_parse_object_context(lua_State *l, json_parse_t *json)
+{
+    json_token_t token;
+
+    /* 3 slots required:
+     * .., table, key, value */
+    json_decode_descend(l, json, 3);
+
+    lua_newtable(l);
+
+    json_next_token(json, &token);
+
+    /* Handle empty objects */
+    if (token.type == T_OBJ_END) {
+        json_decode_ascend(json);
+        return;
+    }
+
+    while (1) {
+        if (token.type != T_STRING)
+            json_throw_parse_error(l, json, "object key string", &token);
+
+        /* Push key */
+        lua_pushlstring(l, token.value.string, token.string_len);
+
+        json_next_token(json, &token);
+        if (token.type != T_COLON)
+            json_throw_parse_error(l, json, "colon", &token);
+
+        /* Fetch value */
+        json_next_token(json, &token);
+        json_process_value(l, json, &token);
+
+        /* Set key = value */
+        lua_rawset(l, -3);
+
+        json_next_token(json, &token);
+
+        if (token.type == T_OBJ_END) {
+            json_decode_ascend(json);
+            return;
+        }
+
+        if (token.type != T_COMMA)
+            json_throw_parse_error(l, json, "comma or object end", &token);
+
+        json_next_token(json, &token);
+    }
+}
+
+/* Handle the array context */
+static void json_parse_array_context(lua_State *l, json_parse_t *json)
+{
+    json_token_t token;
+    int i;
+
+    /* 2 slots required:
+     * .., table, value */
+    json_decode_descend(l, json, 2);
+
+    lua_newtable(l);
+
+    json_next_token(json, &token);
+
+    /* Handle empty arrays */
+    if (token.type == T_ARR_END) {
+        json_decode_ascend(json);
+        return;
+    }
+
+    for (i = 1; ; i++) {
+        json_process_value(l, json, &token);
+        lua_rawseti(l, -2, i);            /* arr[i] = value */
+
+        json_next_token(json, &token);
+
+        if (token.type == T_ARR_END) {
+            json_decode_ascend(json);
+            return;
+        }
+
+        if (token.type != T_COMMA)
+            json_throw_parse_error(l, json, "comma or array end", &token);
+
+        json_next_token(json, &token);
+    }
+}
+
+/* Handle the "value" context */
+static void json_process_value(lua_State *l, json_parse_t *json,
+                               json_token_t *token)
+{
+    switch (token->type) {
+    case T_STRING:
+        lua_pushlstring(l, token->value.string, token->string_len);
+        break;;
+    case T_NUMBER:
+        lua_pushnumber(l, token->value.number);
+        break;;
+    case T_BOOLEAN:
+        lua_pushboolean(l, token->value.boolean);
+        break;;
+    case T_OBJ_BEGIN:
+        json_parse_object_context(l, json);
+        break;;
+    case T_ARR_BEGIN:
+        json_parse_array_context(l, json);
+        break;;
+    case T_NULL:
+        /* In Lua, setting "t[k] = nil" will delete k from the table.
+         * Hence a NULL pointer lightuserdata object is used instead */
+        lua_pushlightuserdata(l, NULL);
+        break;;
+    default:
+        json_throw_parse_error(l, json, "value", token);
+    }
+}
+
+static int json_decode(lua_State *l)
+{
+    json_parse_t json;
+    json_token_t token;
+    size_t json_len;
+
+    luaL_argcheck(l, lua_gettop(l) == 1, 1, "expected 1 argument");
+
+    json.cfg = json_fetch_config(l);
+    json.data = luaL_checklstring(l, 1, &json_len);
+    json.current_depth = 0;
+    json.ptr = json.data;
+
+    /* Detect Unicode other than UTF-8 (see RFC 4627, Sec 3)
+     *
+     * CJSON can support any simple data type, hence only the first
+     * character is guaranteed to be ASCII (at worst: '"'). This is
+     * still enough to detect whether the wrong encoding is in use. */
+    if (json_len >= 2 && (!json.data[0] || !json.data[1]))
+        luaL_error(l, "JSON parser does not support UTF-16 or UTF-32");
+
+    /* Ensure the temporary buffer can hold the entire string.
+     * This means we no longer need to do length checks since the decoded
+     * string must be smaller than the entire json string */
+    json.tmp = strbuf_new(json_len);
+
+    json_next_token(&json, &token);
+    json_process_value(l, &json, &token);
+
+    /* Ensure there is no more input left */
+    json_next_token(&json, &token);
+
+    if (token.type != T_END)
+        json_throw_parse_error(l, &json, "the end", &token);
+
+    strbuf_free(json.tmp);
+
+    return 1;
+}
+
+/* ===== INITIALISATION ===== */
+
+/* Call target function in protected mode with all supplied args.
+ * Assumes target function only returns a single non-nil value.
+ * Convert and return thrown errors as: nil, "error message" */
+static int json_protect_conversion(lua_State *l)
+{
+    int err;
+
+    /* Deliberately throw an error for invalid arguments */
+    luaL_argcheck(l, lua_gettop(l) == 1, 1, "expected 1 argument");
+
+    /* pcall() the function stored as upvalue(1) */
+    lua_pushvalue(l, lua_upvalueindex(1));
+    lua_insert(l, 1);
+    err = lua_pcall(l, 1, 1, 0);
+    if (!err)
+        return 1;
+
+    if (err == LUA_ERRRUN) {
+        lua_pushnil(l);
+        lua_insert(l, -2);
+        return 2;
+    }
+
+    /* Since we are not using a custom error handler, the only remaining
+     * errors are memory related */
+    return luaL_error(l, "Memory allocation error in CJSON protected call");
+}
+
+/* Return cjson module table */
+static int lua_cjson_new(lua_State *l)
+{
+    luaL_Reg reg[] = {
+        { "encode", json_encode },
+        { "decode", json_decode },
+        { "encode_sparse_array", json_cfg_encode_sparse_array },
+        { "encode_max_depth", json_cfg_encode_max_depth },
+        { "decode_max_depth", json_cfg_decode_max_depth },
+        { "encode_number_precision", json_cfg_encode_number_precision },
+        { "encode_keep_buffer", json_cfg_encode_keep_buffer },
+        { "encode_invalid_numbers", json_cfg_encode_invalid_numbers },
+        { "decode_invalid_numbers", json_cfg_decode_invalid_numbers },
+        { "new", lua_cjson_new },
+        { NULL, NULL }
+    };
+
+    /* Initialise number conversions */
+    fpconv_init();
+
+    /* cjson module table */
+    lua_newtable(l);
+
+    /* Register functions with config data as upvalue */
+    json_create_config(l);
+    luaL_setfuncs(l, reg, 1);
+
+    /* Set cjson.null */
+    lua_pushlightuserdata(l, NULL);
+    lua_setfield(l, -2, "null");
+
+    /* Set module name / version fields */
+    lua_pushliteral(l, CJSON_MODNAME);
+    lua_setfield(l, -2, "_NAME");
+    lua_pushliteral(l, CJSON_VERSION);
+    lua_setfield(l, -2, "_VERSION");
+
+    return 1;
+}
+
+/* Return cjson.safe module table */
+static int lua_cjson_safe_new(lua_State *l)
+{
+    const char *func[] = { "decode", "encode", NULL };
+    int i;
+
+    lua_cjson_new(l);
+
+    /* Fix new() method */
+    lua_pushcfunction(l, lua_cjson_safe_new);
+    lua_setfield(l, -2, "new");
+
+    for (i = 0; func[i]; i++) {
+        lua_getfield(l, -1, func[i]);
+        lua_pushcclosure(l, json_protect_conversion, 1);
+        lua_setfield(l, -2, func[i]);
+    }
+
+    return 1;
+}
+
+int luaopen_cjson(lua_State *l)
+{
+    lua_cjson_new(l);
+
+#ifdef ENABLE_CJSON_GLOBAL
+    /* Register a global "cjson" table. */
+    lua_pushvalue(l, -1);
+    lua_setglobal(l, CJSON_MODNAME);
+#endif
+
+    /* Return cjson table */
+    return 1;
+}
+
+int luaopen_cjson_safe(lua_State *l)
+{
+    lua_cjson_safe_new(l);
+
+    /* Return cjson.safe table */
+    return 1;
+}
+
+/* vi:ai et sw=4 ts=4:
+ */
diff --git a/src/lua_cmsgpack.c b/src/lua_cmsgpack.c
new file mode 100644
index 00000000..9ac967e2
--- /dev/null
+++ b/src/lua_cmsgpack.c
@@ -0,0 +1,981 @@
+#include <math.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <assert.h>
+
+#include "lua.h"
+#include "lauxlib.h"
+
+#define LUACMSGPACK_NAME        "cmsgpack"
+#define LUACMSGPACK_SAFE_NAME   "cmsgpack_safe"
+#define LUACMSGPACK_VERSION     "lua-cmsgpack 0.4.0"
+#define LUACMSGPACK_COPYRIGHT   "Copyright (C) 2012, Redis Ltd."
+#define LUACMSGPACK_DESCRIPTION "MessagePack C implementation for Lua"
+
+/* Allows a preprocessor directive to override MAX_NESTING */
+#ifndef LUACMSGPACK_MAX_NESTING
+    #define LUACMSGPACK_MAX_NESTING  16 /* Max tables nesting. */
+#endif
+
+/* Check if float or double can be an integer without loss of precision */
+#define IS_INT_TYPE_EQUIVALENT(x, T) (!isinf(x) && (T)(x) == (x))
+
+#define IS_INT64_EQUIVALENT(x) IS_INT_TYPE_EQUIVALENT(x, int64_t)
+#define IS_INT_EQUIVALENT(x) IS_INT_TYPE_EQUIVALENT(x, int)
+
+/* If size of pointer is equal to a 4 byte integer, we're on 32 bits. */
+#if UINTPTR_MAX == UINT_MAX
+    #define BITS_32 1
+#else
+    #define BITS_32 0
+#endif
+
+#if BITS_32
+    #define lua_pushunsigned(L, n) lua_pushnumber(L, n)
+#else
+    #define lua_pushunsigned(L, n) lua_pushinteger(L, n)
+#endif
+
+/* =============================================================================
+ * MessagePack implementation and bindings for Lua 5.1/5.2.
+ * Copyright(C) 2012 Redis Ltd.
+ *
+ * http://github.com/antirez/lua-cmsgpack
+ *
+ * For MessagePack specification check the following web site:
+ * http://wiki.msgpack.org/display/MSGPACK/Format+specification
+ *
+ * See Copyright Notice at the end of this file.
+ *
+ * CHANGELOG:
+ * 19-Feb-2012 (ver 0.1.0): Initial release.
+ * 20-Feb-2012 (ver 0.2.0): Tables encoding improved.
+ * 20-Feb-2012 (ver 0.2.1): Minor bug fixing.
+ * 20-Feb-2012 (ver 0.3.0): Module renamed lua-cmsgpack (was lua-msgpack).
+ * 04-Apr-2014 (ver 0.3.1): Lua 5.2 support and minor bug fix.
+ * 07-Apr-2014 (ver 0.4.0): Multiple pack/unpack, lua allocator, efficiency.
+ * ========================================================================== */
+
+/* -------------------------- Endian conversion --------------------------------
+ * We use it only for floats and doubles, all the other conversions performed
+ * in an endian independent fashion. So the only thing we need is a function
+ * that swaps a binary string if arch is little endian (and left it untouched
+ * otherwise). */
+
+/* Reverse memory bytes if arch is little endian. Given the conceptual
+ * simplicity of the Lua build system we prefer check for endianess at runtime.
+ * The performance difference should be acceptable. */
+void memrevifle(void *ptr, size_t len) {
+    unsigned char   *p = (unsigned char *)ptr,
+                    *e = (unsigned char *)p+len-1,
+                    aux;
+    int test = 1;
+    unsigned char *testp = (unsigned char*) &test;
+
+    if (testp[0] == 0) return; /* Big endian, nothing to do. */
+    len /= 2;
+    while(len--) {
+        aux = *p;
+        *p = *e;
+        *e = aux;
+        p++;
+        e--;
+    }
+}
+
+/* ---------------------------- String buffer ----------------------------------
+ * This is a simple implementation of string buffers. The only operation
+ * supported is creating empty buffers and appending bytes to it.
+ * The string buffer uses 2x preallocation on every realloc for O(N) append
+ * behavior.  */
+
+typedef struct mp_buf {
+    unsigned char *b;
+    size_t len, free;
+} mp_buf;
+
+void *mp_realloc(lua_State *L, void *target, size_t osize,size_t nsize) {
+    void *(*local_realloc) (void *, void *, size_t osize, size_t nsize) = NULL;
+    void *ud;
+
+    local_realloc = lua_getallocf(L, &ud);
+
+    return local_realloc(ud, target, osize, nsize);
+}
+
+mp_buf *mp_buf_new(lua_State *L) {
+    mp_buf *buf = NULL;
+
+    /* Old size = 0; new size = sizeof(*buf) */
+    buf = (mp_buf*)mp_realloc(L, NULL, 0, sizeof(*buf));
+
+    buf->b = NULL;
+    buf->len = buf->free = 0;
+    return buf;
+}
+
+void mp_buf_append(lua_State *L, mp_buf *buf, const unsigned char *s, size_t len) {
+    if (buf->free < len) {
+        size_t newsize = buf->len+len;
+        if (newsize < buf->len || newsize >= SIZE_MAX/2) abort();
+        newsize *= 2;
+
+        buf->b = (unsigned char*)mp_realloc(L, buf->b, buf->len + buf->free, newsize);
+        buf->free = newsize - buf->len;
+    }
+    memcpy(buf->b+buf->len,s,len);
+    buf->len += len;
+    buf->free -= len;
+}
+
+void mp_buf_free(lua_State *L, mp_buf *buf) {
+    mp_realloc(L, buf->b, buf->len + buf->free, 0); /* realloc to 0 = free */
+    mp_realloc(L, buf, sizeof(*buf), 0);
+}
+
+/* ---------------------------- String cursor ----------------------------------
+ * This simple data structure is used for parsing. Basically you create a cursor
+ * using a string pointer and a length, then it is possible to access the
+ * current string position with cursor->p, check the remaining length
+ * in cursor->left, and finally consume more string using
+ * mp_cur_consume(cursor,len), to advance 'p' and subtract 'left'.
+ * An additional field cursor->error is set to zero on initialization and can
+ * be used to report errors. */
+
+#define MP_CUR_ERROR_NONE   0
+#define MP_CUR_ERROR_EOF    1   /* Not enough data to complete operation. */
+#define MP_CUR_ERROR_BADFMT 2   /* Bad data format */
+
+typedef struct mp_cur {
+    const unsigned char *p;
+    size_t left;
+    int err;
+} mp_cur;
+
+void mp_cur_init(mp_cur *cursor, const unsigned char *s, size_t len) {
+    cursor->p = s;
+    cursor->left = len;
+    cursor->err = MP_CUR_ERROR_NONE;
+}
+
+#define mp_cur_consume(_c,_len) do { _c->p += _len; _c->left -= _len; } while(0)
+
+/* When there is not enough room we set an error in the cursor and return. This
+ * is very common across the code so we have a macro to make the code look
+ * a bit simpler. */
+#define mp_cur_need(_c,_len) do { \
+    if (_c->left < _len) { \
+        _c->err = MP_CUR_ERROR_EOF; \
+        return; \
+    } \
+} while(0)
+
+/* ------------------------- Low level MP encoding -------------------------- */
+
+void mp_encode_bytes(lua_State *L, mp_buf *buf, const unsigned char *s, size_t len) {
+    unsigned char hdr[5];
+    size_t hdrlen;
+
+    if (len < 32) {
+        hdr[0] = 0xa0 | (len&0xff); /* fix raw */
+        hdrlen = 1;
+    } else if (len <= 0xff) {
+        hdr[0] = 0xd9;
+        hdr[1] = len;
+        hdrlen = 2;
+    } else if (len <= 0xffff) {
+        hdr[0] = 0xda;
+        hdr[1] = (len&0xff00)>>8;
+        hdr[2] = len&0xff;
+        hdrlen = 3;
+    } else {
+        hdr[0] = 0xdb;
+        hdr[1] = (len&0xff000000)>>24;
+        hdr[2] = (len&0xff0000)>>16;
+        hdr[3] = (len&0xff00)>>8;
+        hdr[4] = len&0xff;
+        hdrlen = 5;
+    }
+    mp_buf_append(L,buf,hdr,hdrlen);
+    mp_buf_append(L,buf,s,len);
+}
+
+/* we assume IEEE 754 internal format for single and double precision floats. */
+void mp_encode_double(lua_State *L, mp_buf *buf, double d) {
+    unsigned char b[9];
+    float f = d;
+
+    assert(sizeof(f) == 4 && sizeof(d) == 8);
+    if (d == (double)f) {
+        b[0] = 0xca;    /* float IEEE 754 */
+        memcpy(b+1,&f,4);
+        memrevifle(b+1,4);
+        mp_buf_append(L,buf,b,5);
+    } else if (sizeof(d) == 8) {
+        b[0] = 0xcb;    /* double IEEE 754 */
+        memcpy(b+1,&d,8);
+        memrevifle(b+1,8);
+        mp_buf_append(L,buf,b,9);
+    }
+}
+
+void mp_encode_int(lua_State *L, mp_buf *buf, int64_t n) {
+    unsigned char b[9];
+    size_t enclen;
+
+    if (n >= 0) {
+        if (n <= 127) {
+            b[0] = n & 0x7f;    /* positive fixnum */
+            enclen = 1;
+        } else if (n <= 0xff) {
+            b[0] = 0xcc;        /* uint 8 */
+            b[1] = n & 0xff;
+            enclen = 2;
+        } else if (n <= 0xffff) {
+            b[0] = 0xcd;        /* uint 16 */
+            b[1] = (n & 0xff00) >> 8;
+            b[2] = n & 0xff;
+            enclen = 3;
+        } else if (n <= 0xffffffffLL) {
+            b[0] = 0xce;        /* uint 32 */
+            b[1] = (n & 0xff000000) >> 24;
+            b[2] = (n & 0xff0000) >> 16;
+            b[3] = (n & 0xff00) >> 8;
+            b[4] = n & 0xff;
+            enclen = 5;
+        } else {
+            b[0] = 0xcf;        /* uint 64 */
+            b[1] = (n & 0xff00000000000000LL) >> 56;
+            b[2] = (n & 0xff000000000000LL) >> 48;
+            b[3] = (n & 0xff0000000000LL) >> 40;
+            b[4] = (n & 0xff00000000LL) >> 32;
+            b[5] = (n & 0xff000000) >> 24;
+            b[6] = (n & 0xff0000) >> 16;
+            b[7] = (n & 0xff00) >> 8;
+            b[8] = n & 0xff;
+            enclen = 9;
+        }
+    } else {
+        if (n >= -32) {
+            b[0] = ((signed char)n);   /* negative fixnum */
+            enclen = 1;
+        } else if (n >= -128) {
+            b[0] = 0xd0;        /* int 8 */
+            b[1] = n & 0xff;
+            enclen = 2;
+        } else if (n >= -32768) {
+            b[0] = 0xd1;        /* int 16 */
+            b[1] = (n & 0xff00) >> 8;
+            b[2] = n & 0xff;
+            enclen = 3;
+        } else if (n >= -2147483648LL) {
+            b[0] = 0xd2;        /* int 32 */
+            b[1] = (n & 0xff000000) >> 24;
+            b[2] = (n & 0xff0000) >> 16;
+            b[3] = (n & 0xff00) >> 8;
+            b[4] = n & 0xff;
+            enclen = 5;
+        } else {
+            b[0] = 0xd3;        /* int 64 */
+            b[1] = (n & 0xff00000000000000LL) >> 56;
+            b[2] = (n & 0xff000000000000LL) >> 48;
+            b[3] = (n & 0xff0000000000LL) >> 40;
+            b[4] = (n & 0xff00000000LL) >> 32;
+            b[5] = (n & 0xff000000) >> 24;
+            b[6] = (n & 0xff0000) >> 16;
+            b[7] = (n & 0xff00) >> 8;
+            b[8] = n & 0xff;
+            enclen = 9;
+        }
+    }
+    mp_buf_append(L,buf,b,enclen);
+}
+
+void mp_encode_array(lua_State *L, mp_buf *buf, uint64_t n) {
+    unsigned char b[5];
+    size_t enclen;
+
+    if (n <= 15) {
+        b[0] = 0x90 | (n & 0xf);    /* fix array */
+        enclen = 1;
+    } else if (n <= 65535) {
+        b[0] = 0xdc;                /* array 16 */
+        b[1] = (n & 0xff00) >> 8;
+        b[2] = n & 0xff;
+        enclen = 3;
+    } else {
+        b[0] = 0xdd;                /* array 32 */
+        b[1] = (n & 0xff000000) >> 24;
+        b[2] = (n & 0xff0000) >> 16;
+        b[3] = (n & 0xff00) >> 8;
+        b[4] = n & 0xff;
+        enclen = 5;
+    }
+    mp_buf_append(L,buf,b,enclen);
+}
+
+void mp_encode_map(lua_State *L, mp_buf *buf, uint64_t n) {
+    unsigned char b[5];
+    int enclen;
+
+    if (n <= 15) {
+        b[0] = 0x80 | (n & 0xf);    /* fix map */
+        enclen = 1;
+    } else if (n <= 65535) {
+        b[0] = 0xde;                /* map 16 */
+        b[1] = (n & 0xff00) >> 8;
+        b[2] = n & 0xff;
+        enclen = 3;
+    } else {
+        b[0] = 0xdf;                /* map 32 */
+        b[1] = (n & 0xff000000) >> 24;
+        b[2] = (n & 0xff0000) >> 16;
+        b[3] = (n & 0xff00) >> 8;
+        b[4] = n & 0xff;
+        enclen = 5;
+    }
+    mp_buf_append(L,buf,b,enclen);
+}
+
+/* --------------------------- Lua types encoding --------------------------- */
+
+void mp_encode_lua_string(lua_State *L, mp_buf *buf) {
+    size_t len;
+    const char *s;
+
+    s = lua_tolstring(L,-1,&len);
+    mp_encode_bytes(L,buf,(const unsigned char*)s,len);
+}
+
+void mp_encode_lua_bool(lua_State *L, mp_buf *buf) {
+    unsigned char b = lua_toboolean(L,-1) ? 0xc3 : 0xc2;
+    mp_buf_append(L,buf,&b,1);
+}
+
+/* Lua 5.3 has a built in 64-bit integer type */
+void mp_encode_lua_integer(lua_State *L, mp_buf *buf) {
+#if (LUA_VERSION_NUM < 503) && BITS_32
+    lua_Number i = lua_tonumber(L,-1);
+#else
+    lua_Integer i = lua_tointeger(L,-1);
+#endif
+    mp_encode_int(L, buf, (int64_t)i);
+}
+
+/* Lua 5.2 and lower only has 64-bit doubles, so we need to
+ * detect if the double may be representable as an int
+ * for Lua < 5.3 */
+void mp_encode_lua_number(lua_State *L, mp_buf *buf) {
+    lua_Number n = lua_tonumber(L,-1);
+
+    if (IS_INT64_EQUIVALENT(n)) {
+        mp_encode_lua_integer(L, buf);
+    } else {
+        mp_encode_double(L,buf,(double)n);
+    }
+}
+
+void mp_encode_lua_type(lua_State *L, mp_buf *buf, int level);
+
+/* Convert a lua table into a message pack list. */
+void mp_encode_lua_table_as_array(lua_State *L, mp_buf *buf, int level) {
+#if LUA_VERSION_NUM < 502
+    size_t len = lua_objlen(L,-1), j;
+#else
+    size_t len = lua_rawlen(L,-1), j;
+#endif
+
+    mp_encode_array(L,buf,len);
+    luaL_checkstack(L, 1, "in function mp_encode_lua_table_as_array");
+    for (j = 1; j <= len; j++) {
+        lua_pushnumber(L,j);
+        lua_gettable(L,-2);
+        mp_encode_lua_type(L,buf,level+1);
+    }
+}
+
+/* Convert a lua table into a message pack key-value map. */
+void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {
+    size_t len = 0;
+
+    /* First step: count keys into table. No other way to do it with the
+     * Lua API, we need to iterate a first time. Note that an alternative
+     * would be to do a single run, and then hack the buffer to insert the
+     * map opcodes for message pack. Too hackish for this lib. */
+    luaL_checkstack(L, 3, "in function mp_encode_lua_table_as_map");
+    lua_pushnil(L);
+    while(lua_next(L,-2)) {
+        lua_pop(L,1); /* remove value, keep key for next iteration. */
+        len++;
+    }
+
+    /* Step two: actually encoding of the map. */
+    mp_encode_map(L,buf,len);
+    lua_pushnil(L);
+    while(lua_next(L,-2)) {
+        /* Stack: ... key value */
+        lua_pushvalue(L,-2); /* Stack: ... key value key */
+        mp_encode_lua_type(L,buf,level+1); /* encode key */
+        mp_encode_lua_type(L,buf,level+1); /* encode val */
+    }
+}
+
+/* Returns true if the Lua table on top of the stack is exclusively composed
+ * of keys from numerical keys from 1 up to N, with N being the total number
+ * of elements, without any hole in the middle. */
+int table_is_an_array(lua_State *L) {
+    int count = 0, max = 0;
+#if LUA_VERSION_NUM < 503
+    lua_Number n;
+#else
+    lua_Integer n;
+#endif
+
+    /* Stack top on function entry */
+    int stacktop;
+
+    stacktop = lua_gettop(L);
+
+    luaL_checkstack(L, 2, "in function table_is_an_array");
+    lua_pushnil(L);
+    while(lua_next(L,-2)) {
+        /* Stack: ... key value */
+        lua_pop(L,1); /* Stack: ... key */
+        /* The <= 0 check is valid here because we're comparing indexes. */
+#if LUA_VERSION_NUM < 503
+        if ((LUA_TNUMBER != lua_type(L,-1)) || (n = lua_tonumber(L, -1)) <= 0 ||
+            !IS_INT_EQUIVALENT(n))
+#else
+        if (!lua_isinteger(L,-1) || (n = lua_tointeger(L, -1)) <= 0)
+#endif
+        {
+            lua_settop(L, stacktop);
+            return 0;
+        }
+        max = (n > max ? n : max);
+        count++;
+    }
+    /* We have the total number of elements in "count". Also we have
+     * the max index encountered in "max". We can't reach this code
+     * if there are indexes <= 0. If you also note that there can not be
+     * repeated keys into a table, you have that if max==count you are sure
+     * that there are all the keys form 1 to count (both included). */
+    lua_settop(L, stacktop);
+    return max == count;
+}
+
+/* If the length operator returns non-zero, that is, there is at least
+ * an object at key '1', we serialize to message pack list. Otherwise
+ * we use a map. */
+void mp_encode_lua_table(lua_State *L, mp_buf *buf, int level) {
+    if (table_is_an_array(L))
+        mp_encode_lua_table_as_array(L,buf,level);
+    else
+        mp_encode_lua_table_as_map(L,buf,level);
+}
+
+void mp_encode_lua_null(lua_State *L, mp_buf *buf) {
+    unsigned char b[1];
+
+    b[0] = 0xc0;
+    mp_buf_append(L,buf,b,1);
+}
+
+void mp_encode_lua_type(lua_State *L, mp_buf *buf, int level) {
+    int t = lua_type(L,-1);
+
+    /* Limit the encoding of nested tables to a specified maximum depth, so that
+     * we survive when called against circular references in tables. */
+    if (t == LUA_TTABLE && level == LUACMSGPACK_MAX_NESTING) t = LUA_TNIL;
+    switch(t) {
+    case LUA_TSTRING: mp_encode_lua_string(L,buf); break;
+    case LUA_TBOOLEAN: mp_encode_lua_bool(L,buf); break;
+    case LUA_TNUMBER:
+    #if LUA_VERSION_NUM < 503
+        mp_encode_lua_number(L,buf); break;
+    #else
+        if (lua_isinteger(L, -1)) {
+            mp_encode_lua_integer(L, buf);
+        } else {
+            mp_encode_lua_number(L, buf);
+        }
+        break;
+    #endif
+    case LUA_TTABLE: mp_encode_lua_table(L,buf,level); break;
+    default: mp_encode_lua_null(L,buf); break;
+    }
+    lua_pop(L,1);
+}
+
+/*
+ * Packs all arguments as a stream for multiple upacking later.
+ * Returns error if no arguments provided.
+ */
+int mp_pack(lua_State *L) {
+    int nargs = lua_gettop(L);
+    int i;
+    mp_buf *buf;
+
+    if (nargs == 0)
+        return luaL_argerror(L, 0, "MessagePack pack needs input.");
+
+    if (!lua_checkstack(L, nargs))
+        return luaL_argerror(L, 0, "Too many arguments for MessagePack pack.");
+
+    buf = mp_buf_new(L);
+    for(i = 1; i <= nargs; i++) {
+        /* Copy argument i to top of stack for _encode processing;
+         * the encode function pops it from the stack when complete. */
+        luaL_checkstack(L, 1, "in function mp_check");
+        lua_pushvalue(L, i);
+
+        mp_encode_lua_type(L,buf,0);
+
+        lua_pushlstring(L,(char*)buf->b,buf->len);
+
+        /* Reuse the buffer for the next operation by
+         * setting its free count to the total buffer size
+         * and the current position to zero. */
+        buf->free += buf->len;
+        buf->len = 0;
+    }
+    mp_buf_free(L, buf);
+
+    /* Concatenate all nargs buffers together */
+    lua_concat(L, nargs);
+    return 1;
+}
+
+/* ------------------------------- Decoding --------------------------------- */
+
+void mp_decode_to_lua_type(lua_State *L, mp_cur *c);
+
+void mp_decode_to_lua_array(lua_State *L, mp_cur *c, size_t len) {
+    assert(len <= UINT_MAX);
+    int index = 1;
+
+    lua_newtable(L);
+    luaL_checkstack(L, 1, "in function mp_decode_to_lua_array");
+    while(len--) {
+        lua_pushnumber(L,index++);
+        mp_decode_to_lua_type(L,c);
+        if (c->err) return;
+        lua_settable(L,-3);
+    }
+}
+
+void mp_decode_to_lua_hash(lua_State *L, mp_cur *c, size_t len) {
+    assert(len <= UINT_MAX);
+    lua_newtable(L);
+    while(len--) {
+        mp_decode_to_lua_type(L,c); /* key */
+        if (c->err) return;
+        mp_decode_to_lua_type(L,c); /* value */
+        if (c->err) return;
+        lua_settable(L,-3);
+    }
+}
+
+/* Decode a Message Pack raw object pointed by the string cursor 'c' to
+ * a Lua type, that is left as the only result on the stack. */
+void mp_decode_to_lua_type(lua_State *L, mp_cur *c) {
+    mp_cur_need(c,1);
+
+    /* If we return more than 18 elements, we must resize the stack to
+     * fit all our return values.  But, there is no way to
+     * determine how many objects a msgpack will unpack to up front, so
+     * we request a +1 larger stack on each iteration (noop if stack is
+     * big enough, and when stack does require resize it doubles in size) */
+    luaL_checkstack(L, 1,
+        "too many return values at once; "
+        "use unpack_one or unpack_limit instead.");
+
+    switch(c->p[0]) {
+    case 0xcc:  /* uint 8 */
+        mp_cur_need(c,2);
+        lua_pushunsigned(L,c->p[1]);
+        mp_cur_consume(c,2);
+        break;
+    case 0xd0:  /* int 8 */
+        mp_cur_need(c,2);
+        lua_pushinteger(L,(signed char)c->p[1]);
+        mp_cur_consume(c,2);
+        break;
+    case 0xcd:  /* uint 16 */
+        mp_cur_need(c,3);
+        lua_pushunsigned(L,
+            (c->p[1] << 8) |
+             c->p[2]);
+        mp_cur_consume(c,3);
+        break;
+    case 0xd1:  /* int 16 */
+        mp_cur_need(c,3);
+        lua_pushinteger(L,(int16_t)
+            (c->p[1] << 8) |
+             c->p[2]);
+        mp_cur_consume(c,3);
+        break;
+    case 0xce:  /* uint 32 */
+        mp_cur_need(c,5);
+        lua_pushunsigned(L,
+            ((uint32_t)c->p[1] << 24) |
+            ((uint32_t)c->p[2] << 16) |
+            ((uint32_t)c->p[3] << 8) |
+             (uint32_t)c->p[4]);
+        mp_cur_consume(c,5);
+        break;
+    case 0xd2:  /* int 32 */
+        mp_cur_need(c,5);
+        lua_pushinteger(L,
+            ((int32_t)c->p[1] << 24) |
+            ((int32_t)c->p[2] << 16) |
+            ((int32_t)c->p[3] << 8) |
+             (int32_t)c->p[4]);
+        mp_cur_consume(c,5);
+        break;
+    case 0xcf:  /* uint 64 */
+        mp_cur_need(c,9);
+        lua_pushunsigned(L,
+            ((uint64_t)c->p[1] << 56) |
+            ((uint64_t)c->p[2] << 48) |
+            ((uint64_t)c->p[3] << 40) |
+            ((uint64_t)c->p[4] << 32) |
+            ((uint64_t)c->p[5] << 24) |
+            ((uint64_t)c->p[6] << 16) |
+            ((uint64_t)c->p[7] << 8) |
+             (uint64_t)c->p[8]);
+        mp_cur_consume(c,9);
+        break;
+    case 0xd3:  /* int 64 */
+        mp_cur_need(c,9);
+#if LUA_VERSION_NUM < 503
+        lua_pushnumber(L,
+#else
+        lua_pushinteger(L,
+#endif
+            ((int64_t)c->p[1] << 56) |
+            ((int64_t)c->p[2] << 48) |
+            ((int64_t)c->p[3] << 40) |
+            ((int64_t)c->p[4] << 32) |
+            ((int64_t)c->p[5] << 24) |
+            ((int64_t)c->p[6] << 16) |
+            ((int64_t)c->p[7] << 8) |
+             (int64_t)c->p[8]);
+        mp_cur_consume(c,9);
+        break;
+    case 0xc0:  /* nil */
+        lua_pushnil(L);
+        mp_cur_consume(c,1);
+        break;
+    case 0xc3:  /* true */
+        lua_pushboolean(L,1);
+        mp_cur_consume(c,1);
+        break;
+    case 0xc2:  /* false */
+        lua_pushboolean(L,0);
+        mp_cur_consume(c,1);
+        break;
+    case 0xca:  /* float */
+        mp_cur_need(c,5);
+        assert(sizeof(float) == 4);
+        {
+            float f;
+            memcpy(&f,c->p+1,4);
+            memrevifle(&f,4);
+            lua_pushnumber(L,f);
+            mp_cur_consume(c,5);
+        }
+        break;
+    case 0xcb:  /* double */
+        mp_cur_need(c,9);
+        assert(sizeof(double) == 8);
+        {
+            double d;
+            memcpy(&d,c->p+1,8);
+            memrevifle(&d,8);
+            lua_pushnumber(L,d);
+            mp_cur_consume(c,9);
+        }
+        break;
+    case 0xd9:  /* raw 8 */
+        mp_cur_need(c,2);
+        {
+            size_t l = c->p[1];
+            mp_cur_need(c,2+l);
+            lua_pushlstring(L,(char*)c->p+2,l);
+            mp_cur_consume(c,2+l);
+        }
+        break;
+    case 0xda:  /* raw 16 */
+        mp_cur_need(c,3);
+        {
+            size_t l = (c->p[1] << 8) | c->p[2];
+            mp_cur_need(c,3+l);
+            lua_pushlstring(L,(char*)c->p+3,l);
+            mp_cur_consume(c,3+l);
+        }
+        break;
+    case 0xdb:  /* raw 32 */
+        mp_cur_need(c,5);
+        {
+            size_t l = ((size_t)c->p[1] << 24) |
+                       ((size_t)c->p[2] << 16) |
+                       ((size_t)c->p[3] << 8) |
+                       (size_t)c->p[4];
+            mp_cur_consume(c,5);
+            mp_cur_need(c,l);
+            lua_pushlstring(L,(char*)c->p,l);
+            mp_cur_consume(c,l);
+        }
+        break;
+    case 0xdc:  /* array 16 */
+        mp_cur_need(c,3);
+        {
+            size_t l = (c->p[1] << 8) | c->p[2];
+            mp_cur_consume(c,3);
+            mp_decode_to_lua_array(L,c,l);
+        }
+        break;
+    case 0xdd:  /* array 32 */
+        mp_cur_need(c,5);
+        {
+            size_t l = ((size_t)c->p[1] << 24) |
+                       ((size_t)c->p[2] << 16) |
+                       ((size_t)c->p[3] << 8) |
+                       (size_t)c->p[4];
+            mp_cur_consume(c,5);
+            mp_decode_to_lua_array(L,c,l);
+        }
+        break;
+    case 0xde:  /* map 16 */
+        mp_cur_need(c,3);
+        {
+            size_t l = (c->p[1] << 8) | c->p[2];
+            mp_cur_consume(c,3);
+            mp_decode_to_lua_hash(L,c,l);
+        }
+        break;
+    case 0xdf:  /* map 32 */
+        mp_cur_need(c,5);
+        {
+            size_t l = ((size_t)c->p[1] << 24) |
+                       ((size_t)c->p[2] << 16) |
+                       ((size_t)c->p[3] << 8) |
+                       (size_t)c->p[4];
+            mp_cur_consume(c,5);
+            mp_decode_to_lua_hash(L,c,l);
+        }
+        break;
+    default:    /* types that can't be idenitified by first byte value. */
+        if ((c->p[0] & 0x80) == 0) {   /* positive fixnum */
+            lua_pushunsigned(L,c->p[0]);
+            mp_cur_consume(c,1);
+        } else if ((c->p[0] & 0xe0) == 0xe0) {  /* negative fixnum */
+            lua_pushinteger(L,(signed char)c->p[0]);
+            mp_cur_consume(c,1);
+        } else if ((c->p[0] & 0xe0) == 0xa0) {  /* fix raw */
+            size_t l = c->p[0] & 0x1f;
+            mp_cur_need(c,1+l);
+            lua_pushlstring(L,(char*)c->p+1,l);
+            mp_cur_consume(c,1+l);
+        } else if ((c->p[0] & 0xf0) == 0x90) {  /* fix map */
+            size_t l = c->p[0] & 0xf;
+            mp_cur_consume(c,1);
+            mp_decode_to_lua_array(L,c,l);
+        } else if ((c->p[0] & 0xf0) == 0x80) {  /* fix map */
+            size_t l = c->p[0] & 0xf;
+            mp_cur_consume(c,1);
+            mp_decode_to_lua_hash(L,c,l);
+        } else {
+            c->err = MP_CUR_ERROR_BADFMT;
+        }
+    }
+}
+
+int mp_unpack_full(lua_State *L, lua_Integer limit, lua_Integer offset) {
+    size_t len;
+    const char *s;
+    mp_cur c;
+    int cnt; /* Number of objects unpacked */
+    int decode_all = (!limit && !offset);
+
+    s = luaL_checklstring(L,1,&len); /* if no match, exits */
+
+    if (offset < 0 || limit < 0) /* requesting negative off or lim is invalid */
+        return luaL_error(L,
+            "Invalid request to unpack with offset of %d and limit of %d.",
+            (int) offset, (int) len);
+    else if (offset > len)
+        return luaL_error(L,
+            "Start offset %d greater than input length %d.", (int) offset, (int) len);
+
+    if (decode_all) limit = INT_MAX;
+
+    mp_cur_init(&c,(const unsigned char *)s+offset,len-offset);
+
+    /* We loop over the decode because this could be a stream
+     * of multiple top-level values serialized together */
+    for(cnt = 0; c.left > 0 && cnt < limit; cnt++) {
+        mp_decode_to_lua_type(L,&c);
+
+        if (c.err == MP_CUR_ERROR_EOF) {
+            return luaL_error(L,"Missing bytes in input.");
+        } else if (c.err == MP_CUR_ERROR_BADFMT) {
+            return luaL_error(L,"Bad data format in input.");
+        }
+    }
+
+    if (!decode_all) {
+        /* c->left is the remaining size of the input buffer.
+         * subtract the entire buffer size from the unprocessed size
+         * to get our next start offset */
+        size_t new_offset = len - c.left;
+        if (new_offset > LONG_MAX) abort();
+
+        luaL_checkstack(L, 1, "in function mp_unpack_full");
+
+        /* Return offset -1 when we have have processed the entire buffer. */
+        lua_pushinteger(L, c.left == 0 ? -1 : (lua_Integer) new_offset);
+        /* Results are returned with the arg elements still
+         * in place. Lua takes care of only returning
+         * elements above the args for us.
+         * In this case, we have one arg on the stack
+         * for this function, so we insert our first return
+         * value at position 2. */
+        lua_insert(L, 2);
+        cnt += 1; /* increase return count by one to make room for offset */
+    }
+
+    return cnt;
+}
+
+int mp_unpack(lua_State *L) {
+    return mp_unpack_full(L, 0, 0);
+}
+
+int mp_unpack_one(lua_State *L) {
+    lua_Integer offset = luaL_optinteger(L, 2, 0);
+    /* Variable pop because offset may not exist */
+    lua_pop(L, lua_gettop(L)-1);
+    return mp_unpack_full(L, 1, offset);
+}
+
+int mp_unpack_limit(lua_State *L) {
+    lua_Integer limit = luaL_checkinteger(L, 2);
+    lua_Integer offset = luaL_optinteger(L, 3, 0);
+    /* Variable pop because offset may not exist */
+    lua_pop(L, lua_gettop(L)-1);
+
+    return mp_unpack_full(L, limit, offset);
+}
+
+int mp_safe(lua_State *L) {
+    int argc, err, total_results;
+
+    argc = lua_gettop(L);
+
+    /* This adds our function to the bottom of the stack
+     * (the "call this function" position) */
+    lua_pushvalue(L, lua_upvalueindex(1));
+    lua_insert(L, 1);
+
+    err = lua_pcall(L, argc, LUA_MULTRET, 0);
+    total_results = lua_gettop(L);
+
+    if (!err) {
+        return total_results;
+    } else {
+        lua_pushnil(L);
+        lua_insert(L,-2);
+        return 2;
+    }
+}
+
+/* -------------------------------------------------------------------------- */
+const struct luaL_Reg cmds[] = {
+    {"pack", mp_pack},
+    {"unpack", mp_unpack},
+    {"unpack_one", mp_unpack_one},
+    {"unpack_limit", mp_unpack_limit},
+    {0}
+};
+
+int luaopen_create(lua_State *L) {
+    int i;
+    /* Manually construct our module table instead of
+     * relying on _register or _newlib */
+    lua_newtable(L);
+
+    for (i = 0; i < (sizeof(cmds)/sizeof(*cmds) - 1); i++) {
+        lua_pushcfunction(L, cmds[i].func);
+        lua_setfield(L, -2, cmds[i].name);
+    }
+
+    /* Add metadata */
+    lua_pushliteral(L, LUACMSGPACK_NAME);
+    lua_setfield(L, -2, "_NAME");
+    lua_pushliteral(L, LUACMSGPACK_VERSION);
+    lua_setfield(L, -2, "_VERSION");
+    lua_pushliteral(L, LUACMSGPACK_COPYRIGHT);
+    lua_setfield(L, -2, "_COPYRIGHT");
+    lua_pushliteral(L, LUACMSGPACK_DESCRIPTION);
+    lua_setfield(L, -2, "_DESCRIPTION");
+    return 1;
+}
+
+LUALIB_API int luaopen_cmsgpack(lua_State *L) {
+    luaopen_create(L);
+
+#if LUA_VERSION_NUM < 502
+    /* Register name globally for 5.1 */
+    lua_pushvalue(L, -1);
+    lua_setglobal(L, LUACMSGPACK_NAME);
+#endif
+
+    return 1;
+}
+
+LUALIB_API int luaopen_cmsgpack_safe(lua_State *L) {
+    int i;
+
+    luaopen_cmsgpack(L);
+
+    /* Wrap all functions in the safe handler */
+    for (i = 0; i < (sizeof(cmds)/sizeof(*cmds) - 1); i++) {
+        lua_getfield(L, -1, cmds[i].name);
+        lua_pushcclosure(L, mp_safe, 1);
+        lua_setfield(L, -2, cmds[i].name);
+    }
+
+#if LUA_VERSION_NUM < 502
+    /* Register name globally for 5.1 */
+    lua_pushvalue(L, -1);
+    lua_setglobal(L, LUACMSGPACK_SAFE_NAME);
+#endif
+
+    return 1;
+}
+
+/******************************************************************************
+* Copyright (C) 2012 Redis Ltd.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining
+* a copy of this software and associated documentation files (the
+* "Software"), to deal in the Software without restriction, including
+* without limitation the rights to use, copy, modify, merge, publish,
+* distribute, sublicense, and/or sell copies of the Software, and to
+* permit persons to whom the Software is furnished to do so, subject to
+* the following conditions:
+*
+* The above copyright notice and this permission notice shall be
+* included in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+******************************************************************************/
diff --git a/src/lua_struct.c b/src/lua_struct.c
new file mode 100644
index 00000000..c58c8e72
--- /dev/null
+++ b/src/lua_struct.c
@@ -0,0 +1,429 @@
+/*
+** {======================================================
+** Library for packing/unpacking structures.
+** $Id: struct.c,v 1.7 2018/05/11 22:04:31 roberto Exp $
+** See Copyright Notice at the end of this file
+** =======================================================
+*/
+/*
+** Valid formats:
+** > - big endian
+** < - little endian
+** ![num] - alignment
+** x - pading
+** b/B - signed/unsigned byte
+** h/H - signed/unsigned short
+** l/L - signed/unsigned long
+** T   - size_t
+** i/In - signed/unsigned integer with size 'n' (default is size of int)
+** cn - sequence of 'n' chars (from/to a string); when packing, n==0 means
+        the whole string; when unpacking, n==0 means use the previous
+        read number as the string length
+** s - zero-terminated string
+** f - float
+** d - double
+** ' ' - ignored
+*/
+
+
+#include <assert.h>
+#include <ctype.h>
+#include <limits.h>
+#include <stddef.h>
+#include <string.h>
+
+
+#include "lua.h"
+#include "lauxlib.h"
+
+
+#if (LUA_VERSION_NUM >= 502)
+
+#define luaL_register(L,n,f)	luaL_newlib(L,f)
+
+#endif
+
+
+/* basic integer type */
+#if !defined(STRUCT_INT)
+#define STRUCT_INT	long
+#endif
+
+typedef STRUCT_INT Inttype;
+
+/* corresponding unsigned version */
+typedef unsigned STRUCT_INT Uinttype;
+
+
+/* maximum size (in bytes) for integral types */
+#define MAXINTSIZE	32
+
+/* is 'x' a power of 2? */
+#define isp2(x)		((x) > 0 && ((x) & ((x) - 1)) == 0)
+
+/* dummy structure to get alignment requirements */
+struct cD {
+  char c;
+  double d;
+};
+
+
+#define PADDING		(sizeof(struct cD) - sizeof(double))
+#define MAXALIGN  	(PADDING > sizeof(int) ? PADDING : sizeof(int))
+
+
+/* endian options */
+#define BIG	0
+#define LITTLE	1
+
+
+static union {
+  int dummy;
+  char endian;
+} const native = {1};
+
+
+typedef struct Header {
+  int endian;
+  int align;
+} Header;
+
+
+static int getnum (lua_State *L, const char **fmt, int df) {
+  if (!isdigit(**fmt))  /* no number? */
+    return df;  /* return default value */
+  else {
+    int a = 0;
+    do {
+      if (a > (INT_MAX / 10) || a * 10 > (INT_MAX - (**fmt - '0')))
+        luaL_error(L, "integral size overflow");
+      a = a*10 + *((*fmt)++) - '0';
+    } while (isdigit(**fmt));
+    return a;
+  }
+}
+
+
+#define defaultoptions(h)	((h)->endian = native.endian, (h)->align = 1)
+
+
+
+static size_t optsize (lua_State *L, char opt, const char **fmt) {
+  switch (opt) {
+    case 'B': case 'b': return sizeof(char);
+    case 'H': case 'h': return sizeof(short);
+    case 'L': case 'l': return sizeof(long);
+    case 'T': return sizeof(size_t);
+    case 'f':  return sizeof(float);
+    case 'd':  return sizeof(double);
+    case 'x': return 1;
+    case 'c': return getnum(L, fmt, 1);
+    case 'i': case 'I': {
+      int sz = getnum(L, fmt, sizeof(int));
+      if (sz > MAXINTSIZE)
+        luaL_error(L, "integral size %d is larger than limit of %d",
+                       sz, MAXINTSIZE);
+      return sz;
+    }
+    default: return 0;  /* other cases do not need alignment */
+  }
+}
+
+
+/*
+** return number of bytes needed to align an element of size 'size'
+** at current position 'len'
+*/
+static int gettoalign (size_t len, Header *h, int opt, size_t size) {
+  if (size == 0 || opt == 'c') return 0;
+  if (size > (size_t)h->align)
+    size = h->align;  /* respect max. alignment */
+  return (size - (len & (size - 1))) & (size - 1);
+}
+
+
+/*
+** options to control endianess and alignment
+*/
+static void controloptions (lua_State *L, int opt, const char **fmt,
+                            Header *h) {
+  switch (opt) {
+    case  ' ': return;  /* ignore white spaces */
+    case '>': h->endian = BIG; return;
+    case '<': h->endian = LITTLE; return;
+    case '!': {
+      int a = getnum(L, fmt, MAXALIGN);
+      if (!isp2(a))
+        luaL_error(L, "alignment %d is not a power of 2", a);
+      h->align = a;
+      return;
+    }
+    default: {
+      const char *msg = lua_pushfstring(L, "invalid format option '%c'", opt);
+      luaL_argerror(L, 1, msg);
+    }
+  }
+}
+
+
+static void putinteger (lua_State *L, luaL_Buffer *b, int arg, int endian,
+                        int size) {
+  lua_Number n = luaL_checknumber(L, arg);
+  Uinttype value;
+  char buff[MAXINTSIZE];
+  if (n < 0)
+    value = (Uinttype)(Inttype)n;
+  else
+    value = (Uinttype)n;
+  if (endian == LITTLE) {
+    int i;
+    for (i = 0; i < size; i++) {
+      buff[i] = (value & 0xff);
+      value >>= 8;
+    }
+  }
+  else {
+    int i;
+    for (i = size - 1; i >= 0; i--) {
+      buff[i] = (value & 0xff);
+      value >>= 8;
+    }
+  }
+  luaL_addlstring(b, buff, size);
+}
+
+
+static void correctbytes (char *b, int size, int endian) {
+  if (endian != native.endian) {
+    int i = 0;
+    while (i < --size) {
+      char temp = b[i];
+      b[i++] = b[size];
+      b[size] = temp;
+    }
+  }
+}
+
+
+static int b_pack (lua_State *L) {
+  luaL_Buffer b;
+  const char *fmt = luaL_checkstring(L, 1);
+  Header h;
+  int arg = 2;
+  size_t totalsize = 0;
+  defaultoptions(&h);
+  lua_pushnil(L);  /* mark to separate arguments from string buffer */
+  luaL_buffinit(L, &b);
+  while (*fmt != '\0') {
+    int opt = *fmt++;
+    size_t size = optsize(L, opt, &fmt);
+    int toalign = gettoalign(totalsize, &h, opt, size);
+    totalsize += toalign;
+    while (toalign-- > 0) luaL_addchar(&b, '\0');
+    switch (opt) {
+      case 'b': case 'B': case 'h': case 'H':
+      case 'l': case 'L': case 'T': case 'i': case 'I': {  /* integer types */
+        putinteger(L, &b, arg++, h.endian, size);
+        break;
+      }
+      case 'x': {
+        luaL_addchar(&b, '\0');
+        break;
+      }
+      case 'f': {
+        float f = (float)luaL_checknumber(L, arg++);
+        correctbytes((char *)&f, size, h.endian);
+        luaL_addlstring(&b, (char *)&f, size);
+        break;
+      }
+      case 'd': {
+        double d = luaL_checknumber(L, arg++);
+        correctbytes((char *)&d, size, h.endian);
+        luaL_addlstring(&b, (char *)&d, size);
+        break;
+      }
+      case 'c': case 's': {
+        size_t l;
+        const char *s = luaL_checklstring(L, arg++, &l);
+        if (size == 0) size = l;
+        luaL_argcheck(L, l >= (size_t)size, arg, "string too short");
+        luaL_addlstring(&b, s, size);
+        if (opt == 's') {
+          luaL_addchar(&b, '\0');  /* add zero at the end */
+          size++;
+        }
+        break;
+      }
+      default: controloptions(L, opt, &fmt, &h);
+    }
+    totalsize += size;
+  }
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+static lua_Number getinteger (const char *buff, int endian,
+                        int issigned, int size) {
+  Uinttype l = 0;
+  int i;
+  if (endian == BIG) {
+    for (i = 0; i < size; i++) {
+      l <<= 8;
+      l |= (Uinttype)(unsigned char)buff[i];
+    }
+  }
+  else {
+    for (i = size - 1; i >= 0; i--) {
+      l <<= 8;
+      l |= (Uinttype)(unsigned char)buff[i];
+    }
+  }
+  if (!issigned)
+    return (lua_Number)l;
+  else {  /* signed format */
+    Uinttype mask = (Uinttype)(~((Uinttype)0)) << (size*8 - 1);
+    if (l & mask)  /* negative value? */
+      l |= mask;  /* signal extension */
+    return (lua_Number)(Inttype)l;
+  }
+}
+
+
+static int b_unpack (lua_State *L) {
+  Header h;
+  const char *fmt = luaL_checkstring(L, 1);
+  size_t ld;
+  const char *data = luaL_checklstring(L, 2, &ld);
+  size_t pos = luaL_optinteger(L, 3, 1);
+  luaL_argcheck(L, pos > 0, 3, "offset must be 1 or greater");
+  pos--; /* Lua indexes are 1-based, but here we want 0-based for C
+          * pointer math. */
+  int n = 0;  /* number of results */
+  defaultoptions(&h);
+  while (*fmt) {
+    int opt = *fmt++;
+    size_t size = optsize(L, opt, &fmt);
+    pos += gettoalign(pos, &h, opt, size);
+    luaL_argcheck(L, size <= ld && pos <= ld - size,
+                   2, "data string too short");
+    /* stack space for item + next position */
+    luaL_checkstack(L, 2, "too many results");
+    switch (opt) {
+      case 'b': case 'B': case 'h': case 'H':
+      case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* integer types */
+        int issigned = islower(opt);
+        lua_Number res = getinteger(data+pos, h.endian, issigned, size);
+        lua_pushnumber(L, res); n++;
+        break;
+      }
+      case 'x': {
+        break;
+      }
+      case 'f': {
+        float f;
+        memcpy(&f, data+pos, size);
+        correctbytes((char *)&f, sizeof(f), h.endian);
+        lua_pushnumber(L, f); n++;
+        break;
+      }
+      case 'd': {
+        double d;
+        memcpy(&d, data+pos, size);
+        correctbytes((char *)&d, sizeof(d), h.endian);
+        lua_pushnumber(L, d); n++;
+        break;
+      }
+      case 'c': {
+        if (size == 0) {
+          if (n == 0 || !lua_isnumber(L, -1))
+            luaL_error(L, "format 'c0' needs a previous size");
+          size = lua_tonumber(L, -1);
+          lua_pop(L, 1); n--;
+          luaL_argcheck(L, size <= ld && pos <= ld - size,
+                           2, "data string too short");
+        }
+        lua_pushlstring(L, data+pos, size); n++;
+        break;
+      }
+      case 's': {
+        const char *e = (const char *)memchr(data+pos, '\0', ld - pos);
+        if (e == NULL)
+          luaL_error(L, "unfinished string in data");
+        size = (e - (data+pos)) + 1;
+        lua_pushlstring(L, data+pos, size - 1); n++;
+        break;
+      }
+      default: controloptions(L, opt, &fmt, &h);
+    }
+    pos += size;
+  }
+  lua_pushinteger(L, pos + 1);  /* next position */
+  return n + 1;
+}
+
+
+static int b_size (lua_State *L) {
+  Header h;
+  const char *fmt = luaL_checkstring(L, 1);
+  size_t pos = 0;
+  defaultoptions(&h);
+  while (*fmt) {
+    int opt = *fmt++;
+    size_t size = optsize(L, opt, &fmt);
+    pos += gettoalign(pos, &h, opt, size);
+    if (opt == 's')
+      luaL_argerror(L, 1, "option 's' has no fixed size");
+    else if (opt == 'c' && size == 0)
+      luaL_argerror(L, 1, "option 'c0' has no fixed size");
+    if (!isalnum(opt))
+      controloptions(L, opt, &fmt, &h);
+    pos += size;
+  }
+  lua_pushinteger(L, pos);
+  return 1;
+}
+
+/* }====================================================== */
+
+
+
+static const struct luaL_Reg thislib[] = {
+  {"pack", b_pack},
+  {"unpack", b_unpack},
+  {"size", b_size},
+  {NULL, NULL}
+};
+
+
+LUALIB_API int luaopen_struct (lua_State *L);
+
+LUALIB_API int luaopen_struct (lua_State *L) {
+  luaL_register(L, "struct", thislib);
+  return 1;
+}
+
+
+/******************************************************************************
+* Copyright (C) 2010-2018 Lua.org, PUC-Rio.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining
+* a copy of this software and associated documentation files (the
+* "Software"), to deal in the Software without restriction, including
+* without limitation the rights to use, copy, modify, merge, publish,
+* distribute, sublicense, and/or sell copies of the Software, and to
+* permit persons to whom the Software is furnished to do so, subject to
+* the following conditions:
+*
+* The above copyright notice and this permission notice shall be
+* included in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+******************************************************************************/
+
diff --git a/src/strbuf.c b/src/strbuf.c
new file mode 100644
index 00000000..97ee940c
--- /dev/null
+++ b/src/strbuf.c
@@ -0,0 +1,197 @@
+/* strbuf - String buffer routines
+ *
+ * Copyright (c) 2010-2012  Mark Pulford <mark@kyne.com.au>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <stdint.h>
+
+#include "strbuf.h"
+
+static void die(const char *fmt, ...)
+{
+    va_list arg;
+
+    va_start(arg, fmt);
+    vfprintf(stderr, fmt, arg);
+    va_end(arg);
+    fprintf(stderr, "\n");
+
+    abort();
+}
+
+void strbuf_init(strbuf_t *s, size_t len)
+{
+    size_t size;
+
+    if (!len)
+        size = STRBUF_DEFAULT_SIZE;
+    else
+        size = len + 1;
+    if (size < len)
+        die("Overflow, len: %zu", len);
+    s->buf = NULL;
+    s->size = size;
+    s->length = 0;
+    s->dynamic = 0;
+    s->reallocs = 0;
+    s->debug = 0;
+
+    s->buf = malloc(size);
+    if (!s->buf)
+        die("Out of memory");
+
+    strbuf_ensure_null(s);
+}
+
+strbuf_t *strbuf_new(size_t len)
+{
+    strbuf_t *s;
+
+    s = malloc(sizeof(strbuf_t));
+    if (!s)
+        die("Out of memory");
+
+    strbuf_init(s, len);
+
+    /* Dynamic strbuf allocation / deallocation */
+    s->dynamic = 1;
+
+    return s;
+}
+
+static inline void debug_stats(strbuf_t *s)
+{
+    if (s->debug) {
+        fprintf(stderr, "strbuf(%lx) reallocs: %d, length: %zd, size: %zd\n",
+                (long)s, s->reallocs, s->length, s->size);
+    }
+}
+
+/* If strbuf_t has not been dynamically allocated, strbuf_free() can
+ * be called any number of times strbuf_init() */
+void strbuf_free(strbuf_t *s)
+{
+    debug_stats(s);
+
+    if (s->buf) {
+        free(s->buf);
+        s->buf = NULL;
+    }
+    if (s->dynamic)
+        free(s);
+}
+
+char *strbuf_free_to_string(strbuf_t *s, size_t *len)
+{
+    char *buf;
+
+    debug_stats(s);
+
+    strbuf_ensure_null(s);
+
+    buf = s->buf;
+    if (len)
+        *len = s->length;
+
+    if (s->dynamic)
+        free(s);
+
+    return buf;
+}
+
+static size_t calculate_new_size(strbuf_t *s, size_t len)
+{
+    size_t reqsize, newsize;
+
+    if (len <= 0)
+        die("BUG: Invalid strbuf length requested");
+
+    /* Ensure there is room for optional NULL termination */
+    reqsize = len + 1;
+    if (reqsize < len)
+        die("Overflow, len: %zu", len);
+
+    /* If the user has requested to shrink the buffer, do it exactly */
+    if (s->size > reqsize)
+        return reqsize;
+
+    newsize = s->size;
+    if (reqsize >= SIZE_MAX / 2) {
+        newsize = reqsize;
+    } else {
+        /* Exponential sizing */
+        while (newsize < reqsize)
+            newsize *= 2;
+    }
+
+    if (newsize < reqsize)
+        die("BUG: strbuf length would overflow, len: %zu", len);
+
+    return newsize;
+}
+
+
+/* Ensure strbuf can handle a string length bytes long (ignoring NULL
+ * optional termination). */
+void strbuf_resize(strbuf_t *s, size_t len)
+{
+    size_t newsize;
+
+    newsize = calculate_new_size(s, len);
+
+    if (s->debug > 1) {
+        fprintf(stderr, "strbuf(%lx) resize: %zd => %zd\n",
+                (long)s, s->size, newsize);
+    }
+
+    s->size = newsize;
+    s->buf = realloc(s->buf, s->size);
+    if (!s->buf)
+        die("Out of memory, len: %zu", len);
+    s->reallocs++;
+}
+
+void strbuf_append_string(strbuf_t *s, const char *str)
+{
+    size_t i, space;
+
+    space = strbuf_empty_length(s);
+
+    for (i = 0; str[i]; i++) {
+        if (space < 1) {
+            strbuf_resize(s, s->length + 1);
+            space = strbuf_empty_length(s);
+        }
+
+        s->buf[s->length] = str[i];
+        s->length++;
+        space--;
+    }
+}
+
+
+/* vi:ai et sw=4 ts=4:
+ */
diff --git a/src/strbuf.h b/src/strbuf.h
new file mode 100644
index 00000000..c10f83f0
--- /dev/null
+++ b/src/strbuf.h
@@ -0,0 +1,146 @@
+/* strbuf - String buffer routines
+ *
+ * Copyright (c) 2010-2012  Mark Pulford <mark@kyne.com.au>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdarg.h>
+
+/* Size: Total bytes allocated to *buf
+ * Length: String length, excluding optional NULL terminator.
+ * Dynamic: True if created via strbuf_new()
+ */
+
+typedef struct {
+    char *buf;
+    size_t size;
+    size_t length;
+    int dynamic;
+    int reallocs;
+    int debug;
+} strbuf_t;
+
+#ifndef STRBUF_DEFAULT_SIZE
+#define STRBUF_DEFAULT_SIZE 1023
+#endif
+
+/* Initialise */
+extern strbuf_t *strbuf_new(size_t len);
+extern void strbuf_init(strbuf_t *s, size_t len);
+
+/* Release */
+extern void strbuf_free(strbuf_t *s);
+extern char *strbuf_free_to_string(strbuf_t *s, size_t *len);
+
+/* Management */
+extern void strbuf_resize(strbuf_t *s, size_t len);
+static size_t strbuf_empty_length(strbuf_t *s);
+static size_t strbuf_length(strbuf_t *s);
+static char *strbuf_string(strbuf_t *s, size_t *len);
+static void strbuf_ensure_empty_length(strbuf_t *s, size_t len);
+static char *strbuf_empty_ptr(strbuf_t *s);
+static void strbuf_extend_length(strbuf_t *s, size_t len);
+
+/* Update */
+static void strbuf_append_mem(strbuf_t *s, const char *c, size_t len);
+extern void strbuf_append_string(strbuf_t *s, const char *str);
+static void strbuf_append_char(strbuf_t *s, const char c);
+static void strbuf_ensure_null(strbuf_t *s);
+
+/* Reset string for before use */
+static inline void strbuf_reset(strbuf_t *s)
+{
+    s->length = 0;
+}
+
+static inline int strbuf_allocated(strbuf_t *s)
+{
+    return s->buf != NULL;
+}
+
+/* Return bytes remaining in the string buffer
+ * Ensure there is space for a NULL terminator. */
+static inline size_t strbuf_empty_length(strbuf_t *s)
+{
+    return s->size - s->length - 1;
+}
+
+static inline void strbuf_ensure_empty_length(strbuf_t *s, size_t len)
+{
+    if (len > strbuf_empty_length(s))
+        strbuf_resize(s, s->length + len);
+}
+
+static inline char *strbuf_empty_ptr(strbuf_t *s)
+{
+    return s->buf + s->length;
+}
+
+static inline void strbuf_extend_length(strbuf_t *s, size_t len)
+{
+    s->length += len;
+}
+
+static inline size_t strbuf_length(strbuf_t *s)
+{
+    return s->length;
+}
+
+static inline void strbuf_append_char(strbuf_t *s, const char c)
+{
+    strbuf_ensure_empty_length(s, 1);
+    s->buf[s->length++] = c;
+}
+
+static inline void strbuf_append_char_unsafe(strbuf_t *s, const char c)
+{
+    s->buf[s->length++] = c;
+}
+
+static inline void strbuf_append_mem(strbuf_t *s, const char *c, size_t len)
+{
+    strbuf_ensure_empty_length(s, len);
+    memcpy(s->buf + s->length, c, len);
+    s->length += len;
+}
+
+static inline void strbuf_append_mem_unsafe(strbuf_t *s, const char *c, size_t len)
+{
+    memcpy(s->buf + s->length, c, len);
+    s->length += len;
+}
+
+static inline void strbuf_ensure_null(strbuf_t *s)
+{
+    s->buf[s->length] = 0;
+}
+
+static inline char *strbuf_string(strbuf_t *s, size_t *len)
+{
+    if (len)
+        *len = s->length;
+
+    return s->buf;
+}
+
+/* vi:ai et sw=4 ts=4:
+ */
-- 
2.47.0

